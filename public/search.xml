<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>学习KMP</title>
      <link href="/2019/05/03/KMP/"/>
      <url>/2019/05/03/KMP/</url>
      
        <content type="html"><![CDATA[<h2 id="引入"><a href="#引入" class="headerlink" title="引入"></a>引入</h2><ul><li><a href="https://leetcode.com/problems/implement-strstr/" target="_blank" rel="noopener">Implement strStr()</a><ul><li>LeetCode实现String.indexOf()，即返回子串在字符串中第一次出现的索引位置，没有则返回-1，子串为空则返回0</li></ul></li><li>暴力解法<ul><li>从0位置开始，比对与子串是否相同，出现不同则在字符串中往后移一位，再次比较子串，直到找到。</li><li>复杂度<ul><li>设字符串长度为m，要查找的子串长度为n</li><li>时间 O(m*n)</li></ul></li><li>问题<ul><li>每次出现不一致的情况，只向后移动一位，再从头开始比对，很多没有必要</li><li>如：在aaaaaaaaaaaab,查找aaaab</li></ul></li></ul></li></ul><p><img src="https://puui.qpic.cn/fans_admin/0/3_1500912214_1556864943460/0" alt></p><p><img src="https://puui.qpic.cn/fans_admin/0/3_1486517634_1556864983556/0" alt></p><p><img src="https://puui.qpic.cn/fans_admin/0/3_308750603_1556864998323/0" alt></p><h2 id="KMP"><a href="#KMP" class="headerlink" title="KMP"></a>KMP</h2><ul><li><p>概念</p><ul><li>KMP算法要解决的问题就是在字符串（也叫主串）中的模式（pattern）定位问题。说简单点就是我们平时常说的关键字搜索。模式串就是关键字（接下来称它为P），如果它在一个主串（接下来称为T）中出现，就返回它的具体位置，否则返回-1（常用手段）。</li></ul></li><li><p>对于暴力破解的优化思考</p><ul><li>主串不要每次只移一位，可以让它（i）保持不动，移动模式中j的位置</li><li>利用已经部分匹配这个有效信息，保持i指针不回溯，通过修改j指针，让模式串尽量地移动到有效的位置</li></ul></li></ul><p><img src="https://puui.qpic.cn/fans_admin/0/3_308750603_1556865032698/0" alt></p><ul><li>j要怎么移动<ul><li>当匹配失败时，j要移动的下一个位置k。存在着这样的性质：最前面的k个字符和j之前的最后k个字符是一样的</li></ul></li></ul><p><img src="https://puui.qpic.cn/fans_admin/0/3_1486517634_1556865346487/0" alt></p><p><img src="https://puui.qpic.cn/fans_admin/0/3_771348268_1556865899518/0" alt></p><p><img src="https://puui.qpic.cn/fans_admin/0/3_1268522869_1556866125545/0" alt></p><p><img src="https://puui.qpic.cn/fans_admin/0/3_122902507_1556866189608/0" alt></p><ul><li><p>数学表示</p><ul><li>如果k表示不匹配时，j要移动的位置</li><li><p>P[0 ~ k-1] == P[j-k ~ j-1]</p><p><img src="https://puui.qpic.cn/fans_admin/0/3_1268522869_1556866470014/0" alt></p></li><li><p>当T[i] != P[j]时</p><p>有T[i-j ~ i-1] == P[0 ~ j-1]</p><p>由P[0 ~ k-1] == P[j-k ~ j-1]</p><p>必然：T[i-k ~ i-1] == P[0 ~ k-1]</p></li><li><p>因此可以直接将j移动到k而无须再比较前面的k个字符</p></li></ul></li><li><p>怎么找到不匹配时j要移动的k位置</p><ul><li>模式串中每个位置发生不匹配时，所要移动到的k位置都是不同的，每个位置都要计算</li><li>使用next数据来保存模式串中每个位置的k值</li><li>next[j]的值（也就是k）表示，当P[j] != T[i]时，j指针的下一步移动位置</li><li><p>当j为0时，如果这时候不匹配</p><ul><li><p>j已经在最左边了，不可能再移动了，这时候要应该是i指针后移。有next[0] = -1</p><p><img src="https://puui.qpic.cn/fans_admin/0/3_912665407_1556869374669/0" alt></p></li></ul></li><li><p>当j为1</p><ul><li><p>j指针一定是后移到0位置的</p><p><img src="https://puui.qpic.cn/fans_admin/0/3_767595719_1556869496396/0" alt></p></li></ul></li><li><p>其他</p><ul><li>当P[k] == P[j]时</li><li><p>next[j+1] == next[j] + 1</p><p><img src="https://puui.qpic.cn/fans_admin/0/3_912665407_1556869639696/0" alt></p><p><img src="https://puui.qpic.cn/fans_admin/0/3_912665407_1556869662493/0" alt></p></li><li><p>P[k] != P[j]</p></li><li><p>k = next[k]</p><p><img src="https://puui.qpic.cn/fans_admin/0/3_912665407_1556869752648/0" alt></p><p><img src="https://puui.qpic.cn/fans_admin/0/3_912665407_1556870613284/0" alt></p></li></ul></li></ul></li></ul><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul><li><a href="https://www.cnblogs.com/yjiyjige/p/3263858.html#top" target="_blank" rel="noopener">https://www.cnblogs.com/yjiyjige/p/3263858.html#top</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>【毕业设计Minions一期】可视化部分展示</title>
      <link href="/2019/04/24/Minions-Visualization-first/"/>
      <url>/2019/04/24/Minions-Visualization-first/</url>
      
        <content type="html"><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><ul><li>基于Spark Streaming的网站实时流量分析</li></ul><h2 id="技术栈"><a href="#技术栈" class="headerlink" title="技术栈"></a>技术栈</h2><ul><li><p>前端框架</p><ul><li>react</li><li>组件<ul><li>ant-design</li><li>ant-design Pro</li><li>BizCharts</li></ul></li></ul></li><li><p>后端框架</p><ul><li>springboot</li></ul></li><li><p>持久化</p><ul><li>HBase</li><li>MySQL</li></ul></li></ul><h2 id="可视化内容概述"><a href="#可视化内容概述" class="headerlink" title="可视化内容概述"></a>可视化内容概述</h2><ul><li>可视化展示用户访问日志数据和用户行为日志，本设计具体化为”音乐网站”日志分析</li></ul><h2 id="细化展示"><a href="#细化展示" class="headerlink" title="细化展示"></a>细化展示</h2><hr><ul><li>今日访问日志数据指标<ul><li>指标数据模块展示部分，从左向右、从上到下指标维度不断细化</li></ul></li></ul><p><img src="https://wx2.sinaimg.cn/mw1024/6a49516fly1g2dxf2zx0cj21hc0u07h0.jpg" alt></p><ul><li>当前PV（page view）值统计<ul><li>显示周同比、日环比和7日PV均值</li></ul></li></ul><p><img src="https://wx2.sinaimg.cn/mw1024/6a49516fly1g2dxf2u6f5j20gg062t9h.jpg" alt></p><ul><li>7日PV走势<ul><li>PV值在7日周维度上的拓展</li></ul></li></ul><p><img src="https://wx2.sinaimg.cn/mw1024/6a49516fly1g2dxf2u8fvj20fk04cgm3.jpg" alt></p><ul><li>今日实时PV走势<ul><li>每隔30分钟统计前30分钟窗口内PV数据</li><li>是 当前PV统计 在时间维度下的细化</li></ul></li></ul><p><img src="https://wx3.sinaimg.cn/mw1024/6a49516fly1g2dxf2w57fj20fh0anmyl.jpg" alt></p><ul><li>各类目访问统计<ul><li>音乐网站首页下属6个子类目</li><li>统计今日当前时间下各类目访问情况</li><li>是 当前PV值统计 在类目维度下的细化</li></ul></li></ul><p><img src="https://wx3.sinaimg.cn/mw1024/6a49516fly1g2dxer2jnaj20fi0bpmz4.jpg" alt></p><ul><li>各类目访问趋势<ul><li>今日实时PV走势 在类目维度的细化</li><li>亦是 各类目访问统计 在时间维度上的拓展</li></ul></li></ul><p><img src="https://wx2.sinaimg.cn/mw1024/6a49516fly1g2dxer2k6fj20fg0eitcb.jpg" alt></p><ul><li>Top来源网站统计<ul><li>访问日志其他信息统计</li></ul></li></ul><p><img src="https://wx3.sinaimg.cn/mw1024/6a49516fly1g2dxer06woj20f70b6wfk.jpg" alt></p><hr><ul><li>网站历史数据Review<ul><li>可选择日期查看该日相应指标数据</li><li>部分指标与今日数据相同</li><li>增加时间维度对比统计展示</li></ul></li></ul><p><img src="https://wx4.sinaimg.cn/mw1024/6a49516fly1g2dxer7xxnj21hc0u0n8c.jpg" alt></p><ul><li>选择日期模块</li></ul><p><img src="https://wx4.sinaimg.cn/mw1024/6a49516fly1g2dxer2rfgj20910f4jt9.jpg" alt></p><ul><li>30天月PV数据统计</li></ul><p><img src="https://wx3.sinaimg.cn/mw1024/6a49516fly1g2dxeqyzmfj20ff07nq4i.jpg" alt></p><hr><ul><li>音乐网站用户行为分析模拟<ul><li>设计有音乐播放模块，模拟用户音乐播放、收藏、评论行为</li></ul></li></ul><p><img src="https://wx2.sinaimg.cn/mw1024/6a49516fly1g2dxer21m0j21hc0u0qm6.jpg" alt></p><ul><li>音乐模块<ul><li>按钮从左到右，模拟音乐播放、收藏和评论</li><li>音乐播放显示全局提示，模拟播放60秒</li></ul></li></ul><p><img src="https://wx1.sinaimg.cn/mw1024/6a49516fly1g2dxeqw5o6j20700c4ab6.jpg" alt></p><p><img src="https://wx2.sinaimg.cn/mw1024/6a49516fly1g2dxer1oocj219t0ik7ht.jpg" alt></p><p><img src="https://wx4.sinaimg.cn/mw1024/6a49516fly1g2dxe3s5u7j204z02a749.jpg" alt></p><p><img src="https://wx3.sinaimg.cn/mw1024/6a49516fly1g2dxe3sn9zj204x023q2w.jpg" alt></p><ul><li>今日歌曲播放数据<ul><li>从记录的日志中，通过不同维度展示用户操作歌曲的行为</li></ul></li></ul><p><img src="https://wx4.sinaimg.cn/mw1024/6a49516fly1g2dxe3y2z4j21hc0u0al0.jpg" alt></p><ul><li>今日歌曲播放数据一览<ul><li>根据播放数量排列</li></ul></li></ul><p><img src="https://wx2.sinaimg.cn/mw1024/6a49516fly1g2dxe3wuz4j20fi0l8di5.jpg" alt></p><ul><li>近一小时播放TOP歌曲<ul><li>每隔十分钟统计前一个小时窗口期内的播放数据</li><li>是今日歌曲播放总览的子集</li></ul></li></ul><p><img src="https://wx2.sinaimg.cn/mw1024/6a49516fly1g2dxe3umj4j20f30iv75k.jpg" alt></p><ul><li>播放音乐类型统计<ul><li>根据播放歌曲的类型进行统计</li><li>展示各个类型的流行程度</li></ul></li></ul><p><img src="https://wx4.sinaimg.cn/mw1024/6a49516fly1g2dxe3vbvgj20f40el3zz.jpg" alt></p><ul><li>今日TOP10歌曲标签云</li></ul><p><img src="https://wx4.sinaimg.cn/mw1024/6a49516fly1g2dxe3u8lsj20f308uq43.jpg" alt></p><ul><li>其他歌曲信息维度的统计<ul><li>收藏量统计</li><li>评论量统计</li><li>不放在一起是因为可能有的歌有收藏没有评论</li></ul></li></ul><p><img src="https://wx1.sinaimg.cn/mw1024/6a49516fly1g2dxe3uzugj20f80mo76a.jpg" alt></p><hr><h2 id="TODO…"><a href="#TODO…" class="headerlink" title="TODO…"></a>TODO…</h2><ul><li>推荐？协同过滤？</li></ul>]]></content>
      
      
      <categories>
          
          <category> 毕业设计 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>用户行为日志记录方案设计</title>
      <link href="/2019/04/22/user-action-logger-design/"/>
      <url>/2019/04/22/user-action-logger-design/</url>
      
        <content type="html"><![CDATA[<ul><li><p>设计思路</p><ul><li>spark streaming作业根据不同的kafka topic进行消费</li><li>Topics<ul><li>minions_songplay</li><li>minions_songlike</li><li>minions_songcomment</li></ul></li></ul></li><li><p>前端埋点设计</p></li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//播放歌曲记录</span></span><br><span class="line">    songplay(songInfo)&#123;</span><br><span class="line"></span><br><span class="line">        openNotification(songInfo);</span><br><span class="line"></span><br><span class="line">        axios.get(Utils.defaultURIdefaultURI+<span class="string">"/actionLogger"</span>, &#123;</span><br><span class="line">            params:&#123;</span><br><span class="line">                K_topic: <span class="string">'minions_songplay'</span>,</span><br><span class="line">                songId: songInfo.songID</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;).then(<span class="function"><span class="keyword">function</span> (<span class="params">response</span>) </span>&#123;</span><br><span class="line">            <span class="keyword">if</span> (response.data === <span class="number">1</span>)&#123;</span><br><span class="line">                message.success(<span class="string">'添加歌曲播放记录成功'</span>);</span><br><span class="line">                <span class="built_in">console</span>.log(<span class="string">"日志记录成功"</span>)</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="built_in">console</span>.log(<span class="string">"日志记录错误"</span>)</span><br><span class="line">        &#125;).catch(<span class="function"><span class="keyword">function</span> (<span class="params">error</span>) </span>&#123;</span><br><span class="line">            <span class="built_in">console</span>.log(error)</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//收藏歌曲</span></span><br><span class="line">    likesong(songInfo)&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//openNotification(songInfo);</span></span><br><span class="line"></span><br><span class="line">        axios.get(Utils.defaultURIdefaultURI+<span class="string">"/actionLogger"</span>, &#123;</span><br><span class="line">            params:&#123;</span><br><span class="line">                K_topic: <span class="string">'minions_songlike'</span>,</span><br><span class="line">                songId: songInfo.songID</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;).then(<span class="function"><span class="keyword">function</span> (<span class="params">response</span>) </span>&#123;</span><br><span class="line">            <span class="keyword">if</span> (response.data === <span class="number">1</span>)&#123;</span><br><span class="line">                message.success(<span class="string">'收藏成功'</span>);</span><br><span class="line">                <span class="built_in">console</span>.log(<span class="string">"日志记录成功"</span>)</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="built_in">console</span>.log(<span class="string">"日志记录错误"</span>)</span><br><span class="line">        &#125;).catch(<span class="function"><span class="keyword">function</span> (<span class="params">error</span>) </span>&#123;</span><br><span class="line">            <span class="built_in">console</span>.log(error)</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//评论歌曲</span></span><br><span class="line">    comment(songInfo)&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//openNotification(songInfo);</span></span><br><span class="line"></span><br><span class="line">        axios.get(Utils.defaultURIdefaultURI+<span class="string">"/actionLogger"</span>, &#123;</span><br><span class="line">            params:&#123;</span><br><span class="line">                K_topic: <span class="string">'minions_songcomment'</span>,</span><br><span class="line">                songId: songInfo.songID</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;).then(<span class="function"><span class="keyword">function</span> (<span class="params">response</span>) </span>&#123;</span><br><span class="line">            <span class="keyword">if</span> (response.data === <span class="number">1</span>)&#123;</span><br><span class="line">                message.success(<span class="string">'评论成功'</span>);</span><br><span class="line">                <span class="built_in">console</span>.log(<span class="string">"日志记录成功"</span>)</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="built_in">console</span>.log(<span class="string">"日志记录错误"</span>)</span><br><span class="line">        &#125;).catch(<span class="function"><span class="keyword">function</span> (<span class="params">error</span>) </span>&#123;</span><br><span class="line">            <span class="built_in">console</span>.log(error)</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><ul><li>服务端记录</li></ul><p><code>logger.info(&quot;topic:&quot; + k_topic + &quot; songID:&quot; + songID);</code></p><ul><li>log4j</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">log4j.appender.flume = org.apache.flume.clients.log4jappender.Log4jAppender</span><br><span class="line">log4j.appender.flume.Hostname = hadoop000</span><br><span class="line">log4j.appender.flume.Port = 41415</span><br><span class="line">log4j.appender.flume.UnsafeMode = true</span><br><span class="line">log4j.appender.flume.layout=org.apache.log4j.PatternLayout</span><br><span class="line">log4j.appender.flume.layout.ConversionPattern= %d&#123;yyyy-MM-dd HH:mm:ss,SSS&#125; [%t] [%c] [%p] - %m%n</span><br></pre></td></tr></table></figure><p><code>2019-04-22 13:58:04,419 [http-nio-8080-exec-9] [com.chaoyue.minions.controller.ActionLogController] [INFO] - topic:minions_songlike songID:13</code></p><ul><li>spark streaming作业根据不同kafka topic划分</li></ul>]]></content>
      
      
      <categories>
          
          <category> 技术总结 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 开发相关 </tag>
            
            <tag> 毕业设计 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>访问行为mock</title>
      <link href="/2019/04/22/mock-accesslog-python/"/>
      <url>/2019/04/22/mock-accesslog-python/</url>
      
        <content type="html"><![CDATA[<p>模拟用户访问的Python脚本</p><ul><li>generate_log.py</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#coding=UTF-8</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> random</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"></span><br><span class="line">url_paths = &#123;</span><br><span class="line"><span class="string">"class/112.html"</span>:<span class="number">10</span>,</span><br><span class="line"><span class="string">"class/128.html"</span>:<span class="number">5</span>,</span><br><span class="line"><span class="string">"class/145.html"</span>:<span class="number">8</span>,</span><br><span class="line"><span class="string">"class/146.html"</span>:<span class="number">10</span>,</span><br><span class="line"><span class="string">"class/131.html"</span>:<span class="number">3</span>,</span><br><span class="line"><span class="string">"class/130.html"</span>:<span class="number">2</span>,</span><br><span class="line"><span class="string">"learn/821"</span>:<span class="number">1</span>,</span><br><span class="line"><span class="string">"course/list"</span>:<span class="number">1</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">ip_slices = [<span class="number">132</span>,<span class="number">156</span>,<span class="number">124</span>,<span class="number">10</span>,<span class="number">29</span>,<span class="number">167</span>,<span class="number">143</span>,<span class="number">187</span>,<span class="number">30</span>,<span class="number">46</span>,<span class="number">55</span>,<span class="number">63</span>,<span class="number">72</span>,<span class="number">87</span>,<span class="number">98</span>,<span class="number">168</span>]</span><br><span class="line"></span><br><span class="line">http_referers = [</span><br><span class="line"><span class="string">"http://www.baidu.com/s?wd=&#123;query&#125;"</span>,</span><br><span class="line"><span class="string">"https://www.sogou.com/web?query=&#123;query&#125;"</span>,</span><br><span class="line"><span class="string">"http://cn.bing.com/search?q=&#123;query&#125;"</span>,</span><br><span class="line"><span class="string">"https://search.yahoo.com/search?p=&#123;query&#125;"</span>,</span><br><span class="line">]</span><br><span class="line"></span><br><span class="line">search_keyword = [</span><br><span class="line"><span class="string">"新近发布"</span>,</span><br><span class="line"><span class="string">"为你推荐"</span>,</span><br><span class="line"><span class="string">"今日歌单"</span>,</span><br><span class="line"><span class="string">"瞩目艺人"</span>,</span><br><span class="line"><span class="string">"今日专辑"</span></span><br><span class="line">]</span><br><span class="line"></span><br><span class="line">status_codes = [<span class="string">"200"</span>,<span class="string">"404"</span>,<span class="string">"500"</span>]</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">sample_url</span><span class="params">()</span>:</span></span><br><span class="line">all_data = []</span><br><span class="line"><span class="keyword">for</span> v, w <span class="keyword">in</span> url_paths.items():</span><br><span class="line">temp = []</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(w):</span><br><span class="line">temp.append(v)</span><br><span class="line">all_data.extend(temp)</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> random.sample(all_data, <span class="number">1</span>)[<span class="number">0</span>]</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">sample_ip</span><span class="params">()</span>:</span></span><br><span class="line">slice = random.sample(ip_slices , <span class="number">4</span>)</span><br><span class="line"><span class="keyword">return</span> <span class="string">"."</span>.join([str(item) <span class="keyword">for</span> item <span class="keyword">in</span> slice])</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">sample_referer</span><span class="params">()</span>:</span></span><br><span class="line"><span class="keyword">if</span> random.uniform(<span class="number">0</span>, <span class="number">1</span>) &gt; <span class="number">0.2</span>:</span><br><span class="line"><span class="keyword">return</span> <span class="string">"-"</span></span><br><span class="line"></span><br><span class="line">refer_str = random.sample(http_referers, <span class="number">1</span>)</span><br><span class="line">query_str = random.sample(search_keyword, <span class="number">1</span>)</span><br><span class="line"><span class="keyword">return</span> refer_str[<span class="number">0</span>].format(query=query_str[<span class="number">0</span>])</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">sample_status_code</span><span class="params">()</span>:</span></span><br><span class="line"><span class="keyword">return</span> random.sample(status_codes, <span class="number">1</span>)[<span class="number">0</span>]</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">generate_log</span><span class="params">()</span>:</span></span><br><span class="line"></span><br><span class="line">time_str = time.strftime(<span class="string">"%Y-%m-%d %H:%M:%S"</span>, time.localtime())</span><br><span class="line">now_hour = time.strftime(<span class="string">"%H"</span>, time.localtime())</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> now_hour &lt; <span class="string">"01"</span>:</span><br><span class="line">count = random.randint(<span class="number">80</span>,<span class="number">100</span>)</span><br><span class="line"><span class="keyword">elif</span> now_hour &lt; <span class="string">"02"</span>:</span><br><span class="line">count = random.randint(<span class="number">60</span>,<span class="number">85</span>)</span><br><span class="line"><span class="keyword">elif</span> now_hour &lt; <span class="string">"03"</span>:</span><br><span class="line">count = random.randint(<span class="number">50</span>,<span class="number">75</span>)</span><br><span class="line"><span class="keyword">elif</span> now_hour &lt; <span class="string">"05"</span>:</span><br><span class="line">count = random.randint(<span class="number">30</span>,<span class="number">60</span>)</span><br><span class="line"><span class="keyword">elif</span> now_hour &lt; <span class="string">"06"</span>:</span><br><span class="line">count = random.randint(<span class="number">50</span>,<span class="number">65</span>)</span><br><span class="line"><span class="keyword">elif</span> now_hour &lt; <span class="string">"08"</span>:</span><br><span class="line">count = random.randint(<span class="number">70</span>,<span class="number">85</span>)</span><br><span class="line"><span class="keyword">elif</span> now_hour &lt; <span class="string">"10"</span>:</span><br><span class="line">count = random.randint(<span class="number">70</span>,<span class="number">95</span>)</span><br><span class="line"><span class="keyword">elif</span> now_hour &lt; <span class="string">"11"</span>:</span><br><span class="line">count = random.randint(<span class="number">80</span>,<span class="number">100</span>)</span><br><span class="line"><span class="keyword">elif</span> now_hour &lt; <span class="string">"13"</span>:</span><br><span class="line">count = random.randint(<span class="number">95</span>,<span class="number">150</span>)</span><br><span class="line"><span class="keyword">elif</span> now_hour &lt; <span class="string">"15"</span>:</span><br><span class="line">count = random.randint(<span class="number">90</span>,<span class="number">130</span>)</span><br><span class="line"><span class="keyword">elif</span> now_hour &lt; <span class="string">"17"</span>:</span><br><span class="line">count = random.randint(<span class="number">80</span>,<span class="number">120</span>)</span><br><span class="line"><span class="keyword">elif</span> now_hour &lt; <span class="string">"18"</span>:</span><br><span class="line">count = random.randint(<span class="number">85</span>,<span class="number">130</span>)</span><br><span class="line"><span class="keyword">elif</span> now_hour &lt; <span class="string">"19"</span>:</span><br><span class="line">count = random.randint(<span class="number">100</span>,<span class="number">120</span>)</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">count = random.randint(<span class="number">110</span>,<span class="number">160</span>)</span><br><span class="line"></span><br><span class="line">f = open(<span class="string">"/home/hadoop/data/project/logs/access.log"</span>,<span class="string">"w+"</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> count &gt;= <span class="number">1</span>:</span><br><span class="line">query_log = <span class="string">"&#123;ip&#125;\t&#123;local_time&#125;\t\"GET /&#123;url&#125; HTTP/1.1\"\t&#123;status_code&#125;\t&#123;referer&#125;"</span>.format(url=sample_url(), ip=sample_ip(), referer=sample_referer(), status_code=sample_status_code(),local_time=time_str)</span><br><span class="line"></span><br><span class="line">f.write(query_log + <span class="string">"\n"</span>)</span><br><span class="line"></span><br><span class="line">count = count - <span class="number">1</span> </span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">generate_log()</span><br></pre></td></tr></table></figure><ul><li>定时执行脚本<ul><li>Linux crontab</li><li><a href="https://tool.lu/crontab/" target="_blank" rel="noopener">工具网站</a></li></ul></li></ul>]]></content>
      
      
      <categories>
          
          <category> 技术总结 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 毕业设计 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>每周记录📝（190420）</title>
      <link href="/2019/04/20/weekly-report-190420/"/>
      <url>/2019/04/20/weekly-report-190420/</url>
      
        <content type="html"><![CDATA[<p><img src="https://wx1.sinaimg.cn/mw1024/6a49516fly1g294xszz4gj23402c0qv7.jpg" alt></p><p>这周吃的铁板烧！大学里面最喜欢吃的东西，害怕以后就吃不到了。</p><p>这周收到南洋理工CCA的offer了，IS被拒了。其实吧，我更想上IS，但是看了一下IS的课程，感觉除了个别及门，其他的在本科也有学过。<br>CCA的话，就偏向控制之类的，我对这方面兴趣不大吧，以后就想做软件、大数据方面的。在贴吧上看到有学长说，找工作其实看自己的能力，确实也是的，所以CCA上也可以，主要我就是想出去。<br>另外国立大学的申请还没有下来，有点捉急，因为国大有SO，如果国大有的话，我更愿意接受国大的，去签SO。</p><p>这周前四天集中做毕设，效果如图：</p><p><img src="https://wx3.sinaimg.cn/mw1024/6a49516fly1g294xqbiggj21i00ustmi.jpg" alt></p><p><img src="https://wx3.sinaimg.cn/mw1024/6a49516fly1g294xqbic3j21i00us14u.jpg" alt></p><p><img src="https://wx1.sinaimg.cn/mw1024/6a49516fly1g294xqa08vj21i00usgwg.jpg" alt></p><p>维度细化了，界面交互也有了逻辑。有问题就是分类别统计30分钟窗口的时候，记录的rowkey设计有问题，所以在零点的左右会出现问题，我是按date在hbase中取值，如果window横跨零点左右，前一天就统计不到。</p><p>另外，行为分析还要增添一点东西。</p>]]></content>
      
      
      <categories>
          
          <category> 每周记录 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>学习HBase JAVA API</title>
      <link href="/2019/04/19/StudyHBaseJavaAPI/"/>
      <url>/2019/04/19/StudyHBaseJavaAPI/</url>
      
        <content type="html"><![CDATA[<h2 id="网站"><a href="#网站" class="headerlink" title="网站"></a>网站</h2><ul><li><a href="https://www.baeldung.com/hbase" target="_blank" rel="noopener">HBase with Java</a></li><li><a href="https://www.bilibili.com/video/av21911076" target="_blank" rel="noopener">HBase表概念</a></li><li><a href="https://www.jianshu.com/p/fb4bd7a2a23e" target="_blank" rel="noopener">Filter 过滤器</a></li></ul><h2 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h2><ul><li><p>Column Family</p><ul><li>列族是列的集合</li><li>表可以有一个或多个列族</li><li>属于同一个列族的所有列前缀相同<ul><li>containInfo:fname</li><li>containInfo:lname</li></ul></li><li>表按照列族维度进行存储，一个列族的数据存在一起</li><li>对一个列族可以单独定义存储属性调优，比如：一个列族存储图片数据，那么就可以对这个列族进行存储压缩</li><li>一个列族想有多少列都可宜，在进行数据添加操作的时候插入即可。不用修改表定义，在创建表的时候，定好列族就可以<br>*设计原则<ul><li>不经常在一起访问的数据分开设计，比如：一个用户信息的表，可以将用户名、真实姓名、花名放在一个列族，将头像放在另一个列族</li><li>使用不同列族存储设置时分开设计</li></ul></li></ul></li><li><p>Columns 列</p><ul><li>列中包含表的数据</li><li>可以动态实时地创建</li></ul></li><li><p>Rows 行</p><ul><li>每一行有一个行键（RowKey)</li><li>RowKey类似于关系型数据库的主键</li><li>RowKey设计原则：方便scan操作，结合具体业务</li><li>行按照行键排序进行存储，这样就提高了检索效率</li></ul></li><li><p>Cell 单元</p><ul><li>行与列的交叉点</li><li>版本化，支持多个版本，更新之前的数据可以保存（要定义），比如，QQ头像可以看到原来的头像</li><li>内容是不可分割的</li><li>存储的是byte array字节数组，无字段类型。只要能转成byte array的都可以存</li><li>单元为空时，物理上是不存储的</li></ul></li></ul><h2 id="HBase-Java-API"><a href="#HBase-Java-API" class="headerlink" title="HBase Java API"></a>HBase Java API</h2><ul><li><a href="https://www.jianshu.com/p/3c85060901da" target="_blank" rel="noopener">HBase Java API 01：基础操作</a></li><li><a href="https://www.jianshu.com/p/fb4bd7a2a23e" target="_blank" rel="noopener">HBase Java API 02：过滤器</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> 技术总结 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>每周记录📝（190414）</title>
      <link href="/2019/04/14/weekly-report-190414/"/>
      <url>/2019/04/14/weekly-report-190414/</url>
      
        <content type="html"><![CDATA[<p><img src="https://wx4.sinaimg.cn/mw1024/6a49516fly1g21zk7ocndj22482tq7wh.jpg" alt></p><p>上一周没有周记，因为清明节回外婆家了。比较忙，也没有带电脑。<br>所以说，真的好像要自己的一台电脑啊！</p><p>另外也就是说，我的毕设在清明节之前的周四之后就没有弄过了！LeetCode也没有刷！真的很罪恶了。<br>这周开始全身心投入！</p><p>这里先定一下这周的计划：</p><ul><li>学习HBase RowKey的设计，以及java API的学习，记笔记。</li><li>用BizCharts完成毕设页面浏览信息的时间维度细化。</li><li>细化页面行为信息</li></ul><p>OK，展示一下目前毕设的状态：</p><p><img src="https://wx4.sinaimg.cn/mw1024/6a49516fly1g2207nk3atj21gn0u0tjq.jpg" alt></p><p><img src="https://wx2.sinaimg.cn/mw1024/6a49516fly1g2207nmb18j21gn0u0kcv.jpg" alt></p><p>另外，喜欢上喝铁观音。自己一周之内被骗了2次，损失36元！谨记！</p><p>be humble！</p>]]></content>
      
      
      <categories>
          
          <category> 每周记录 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>【翻译】弹性分布式数据集：基于内存的集群计算的容错性抽象</title>
      <link href="/2019/04/13/tanslate-Resilient-Distributed-Datasets-A-Fault-Tolerant-Abstraction%E2%80%93for-In-Memory-Cluster-Computing/"/>
      <url>/2019/04/13/tanslate-Resilient-Distributed-Datasets-A-Fault-Tolerant-Abstraction%E2%80%93for-In-Memory-Cluster-Computing/</url>
      
        <content type="html"><![CDATA[<h2 id="context"><a href="#context" class="headerlink" title="context"></a>context</h2><p>大概用了16个小时完成了这篇关于RDD论文的翻译，这篇论文奠定了Spark的设计基础。</p><p>原文:<a href="https://www.usenix.org/system/files/conference/nsdi12/nsdi12-final138.pdf" target="_blank" rel="noopener">Resilient Distributed Datasets: A Fault-Tolerant Abstraction for In-Memory Cluster Computing</a></p><p>推荐先看林子雨老师关于RDD的<a href="http://dblab.xmu.edu.cn/blog/985-2/" target="_blank" rel="noopener">解释</a></p><h2 id="摘要"><a href="#摘要" class="headerlink" title="摘要"></a>摘要</h2><p>本文提出了一个分布式内存抽象的概念–弹性分布式数据集（Resilient Distributed Datasets，以下称为RDDs），其能够让开发人员以容错的方式在大规模集群上进行基于内存的计算。RDDs的提出是由于现有的两种计算框架并不高效：迭代式算法和交互式数据挖掘工具。在内存中操作数据可以将前两种计算方式的效率提高一个数量级。RDDs提供了一种受限的共享内存，是基于粗粒度的转换操作而不是细粒度的状态同步。尽管如此，RDDs依然能够表示多种类型的计算，包括专用的迭代编程模型（如Pregel）和一些新的应用模型。我们通过在Spark上评估各种应用和基准，实现了RDDs。</p><h2 id="1-引言"><a href="#1-引言" class="headerlink" title="1 引言"></a>1 引言</h2><p>集群计算框架，如MapReduce[10]和Dryad[19]，已经被广泛地运用于大规模数据分析。这些系统能够让用户在不用考虑任务调度和容错的前提下，使用一系列高级的操作进行并行计算。</p><p>虽然这些框架为获取集权计算资源提供了大量的抽象，但是缺少对分布式内存的运用。这使他们对于一类新兴的应用十分低效：它们在不同的计算阶段<em>重用</em>中间结果。数据重用在<em>迭代式</em>机器学习和图算法中十分常见，包括PageRank、K-means聚类和逻辑回归。另一个明显的用例是<em>交互式</em>数据挖掘，用户在同样的数据子集上进行ad-hoc查询。然而不好的是，对于现在的框架，在不同计算阶段之间重用数据（如，在两个MapReduce的job之间）的唯一方式是将其写入外部稳定存储系统中，如，分布式文件系统。由于数据的复制、硬盘I/O和序列化，导致了大量的成本开销，并占据了应用运行的大部分时间。</p><p>在意识到这个问题之后，研究人员针对需要数据重用的应用开发了专门的框架。比如，迭代式图计算系统Pregel[22]，其将中间数据存放在内存中，而HaLoop[7]提供了一种迭代式MapReduce接口。无论如何，这些框架仅支持特定的计算模式（如，循环一系列的MapReduce步骤），并隐式地提供这些模式的数据共享。它们没有提供更加通用的数据重用的抽象，如，让用户直接向内存中装载数据集，并对其进行ad-hoc查询。</p><p>在这篇论文中，我们提出了一种能够广泛运用于各种应用中高效的数据重用抽象，<em>弹性分布式数据集</em>（RDDs）。RDDs是一个容错的、并行的数据结构，能够让用户明确地在内存中持久化中间结果，控制其分区以优化数据的放置和使用丰富的操作符对其进行处理。</p><p>设计RDDs的主要挑战是，定义一个能够高效容错能力的编程接口。现有的基于集群的内存存储抽象，如分布式共享内存、键值对存储、数据库和Piccolo，提供了基于细粒度更新可变状态的接口（如，表中的cell）。运用这些接口时，达到数据容错的唯一方式是在不同的机器之间进行数据的冗余或者记录更新日志。这两种方法对于数据密集型工作来说代价高昂，因为他们需要在集群网络间复制大量数据，而网络带宽远小于RAM带宽，同时还会产生大量数据存储开销。</p><p>相比于这些系统，RDDs提供基于粗粒度转换的，可用于大量数据项进行相同操作的接口（如，map,filter和join）。这使得RDDs能够通过记录产生数据集的一系列转换操作（称之为lineage），而不是记录真实的数据，来提高容错的效率【1当lineage链过长时，对一些RDDs进行检查点（checkpoint）设置可能更加有用，我们在5.4节对其进行讨论】。如果一个分区的RDD丢失了，它有足够的信息知道自己是如何从其他的RDD产生的，从而重新计算该分区。因此，丢失的数据可以很快地恢复，而不需要代价昂贵的复制。</p><p>基于粗粒度转换的接口乍一看是有局限性的，但RDDs对于许多并行应用都非常适用，因为这些应用本质上就是会对多种数据项进行相同的操作。为此，我们证明了RDDs高效地运用于表达各种已经被现有的分布式系统所实现的集群编程模型，包括MapReduce，DryadLINQ,，SQL，Pregel 和 HaLoop，以及这些系统无法实现的新应用，如交互式数据挖掘。RDDs能够作为被用来解决前面提到的计算需求而引入的新框架的证据，是因为其强大的抽象能力。</p><p>我们已经在一个被用于UC Berkeley的实验环境和许多公司生产环境下的应用–Spark上，实现了RDDs。Spark提供了一个运用Scala语言，类似DryadLINQ的易用的语言集成编程接口。另外，Spark还可以在Scala解释器中进行交互式大数据集的查询。我们相信Spark会是第一个运用通用编程语言完成交互式速度下集群内存数据挖掘的系统。</p><p>我们通过微基准测试和用户应用对RDDs和Spark进行评估。我们得出，Spark在迭代式应用上比Hadoop快20倍，在真实数据报表分析上快40倍，并且能够在5-7秒的延迟内完成1TB数据集的交互式扫描。更加根本地，为了说明RDDs的通用性，我们在Spark上实现了Pregel和HaLoop的编程模型，包括用一些相对较小的库（每个库大概200行代码）实现它们所采用存储优化策略。</p><p>这篇论文首先介绍RDDs的概览（第2部分）和Spark（第3部分），然后讨论RDDs的内部表示（第4部分），实现（第5部分），和一些实验结果（第6部分）。最后，我们讨论了用RDDs实现几个现有的集群编程模型（第7部分），相关研究工作（第8部分）和总结。</p><h2 id="2-弹性分布式数据集（RDDs）"><a href="#2-弹性分布式数据集（RDDs）" class="headerlink" title="2 弹性分布式数据集（RDDs）"></a>2 弹性分布式数据集（RDDs）</h2><p>这一部分提供关于RDDs的概述。先定义RDDs（2.1节），介绍其在Spark中的编程接口（2.2节）。然后将RDDs与细粒度共享内存抽象进行比较（2.3节）。最后讨论RDD模型的限制（2.4节）。</p><h3 id="2-1-RDD抽象"><a href="#2-1-RDD抽象" class="headerlink" title="2.1 RDD抽象"></a>2.1 RDD抽象</h3><p>一个RDD是只读的，是将记录进行分区的集合。RDDs只能由（1）稳定物理存储中的数据集（2）其他RDDs通过明确的操作产生。我们称这些操作为转换（transformations）以区别其他对RDDs的操作。转换的例子包括map，filter和join。【2 虽然单个RDDs是不可变的，但是可以通过多个RDDs来表示不同版本的数据集以实现多状态。我们让RDDs不可变以使lineage图表示更简便，但这也相当于将我们的抽象变成版本化数据并在lineage图中追踪不同版本】</p><p>RDDs不需要都实体化。一个RDD有足够的信息了解自己是如何从其他数据集产生的（lineage）并通过信息从稳定的物理存储中计算出自己的分区。这一强大特性的本质是，程序能够在RDD重建之后对其进行引用。</p><p>最后一点，用户可以对RDDs进行2方面的控制：持久化和分区。用户可以表明将要重用的RDDs并为其选择存储策略（如，内存存储）。也可以将RDDs的元素通过特定键值进行分区。这些功能对于存储优化特别有用，比如保证两个将要进行join操作的数据集都进行了相同的哈希分区。</p><h3 id="2-2-Spark编程接口"><a href="#2-2-Spark编程接口" class="headerlink" title="2.2 Spark编程接口"></a>2.2 Spark编程接口</h3><p>Spark暴露了类似DryadLINQ和FlumeJava的RDDs语言集成API，每个数据集都被表示成一个对象，并通过执行方法在这些对象上进行转换操作（transformations）。</p><p>开发人员通过将物理存储上的数据集进行转换（如，map和filter）来定义一个或多个RDDs。然后可以用动作（actions）对这些RDDs进行操作，这些操作向应用返回值或者向存储系统产生外部数据。动作（actions）的例子包括，count（返回数据集中元素的数目），collect（返回元素本身）和save（将数据集输出到外部存储系统）。像DryadLINQ一样，Spark在遇到一个动作操作时才会真正计算出RDDs，所以其可以对转换（transformations）进行流水线操作。</p><p>此外，开发人员还可以调用persist方法来声明他们想重用的RDDs。Spark默认会将RDDs留存在内存中，但是会在没有足够RAM的情况下将它们溢出到硬盘。用户可以采用其他的持久化策略，如通过persist标价，将特定RDD只存在硬盘上或在机器之间进行备份。最后，用户可以为每个RDD设置优先级来表明当需要时，将哪一个内存中的数据溢出到硬盘中。</p><h4 id="2-2-1-例子：控制台日志挖掘"><a href="#2-2-1-例子：控制台日志挖掘" class="headerlink" title="2.2.1 例子：控制台日志挖掘"></a>2.2.1 例子：控制台日志挖掘</h4><p>假设一个网页服务出现错误，管理员想在HDFS中兆字节规模的日志中找到原因。应用Spark，管理员能够将错误信息从多个结点的日志中导入RAM，并交互式的进行查询。她会键入以下代码：</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">lines = spark.textFile(<span class="string">"hdfs://..."</span>)</span><br><span class="line">errors = lines.filter(_.startsWith(<span class="string">"ERROR"</span>))</span><br><span class="line">errors.persist()</span><br></pre></td></tr></table></figure><p>第一行从一个HDFS文件（文本行集合）定义了一个RDD，并在第二行产生过滤后的RDD。</p><p>第三行将errors持久化在内存中，这样就能被查询。注意filter的参数是一个闭包的Scala语法。</p><p>到目前为止，并没有在集群上运行作业。但是，用户可以对RDD进行动作（actions）操作，如计算消息的数目：</p><p><code>errors.count()</code></p><p>这位用户也可以对该RDD进行进一步的转换操作并运用他们的结果，如下：</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Count errors mentioning MySQL:</span></span><br><span class="line">errors.filter(_.contains(<span class="string">"MySQL"</span>)).count()</span><br><span class="line"><span class="comment">// Return the time fields of errors mentioning</span></span><br><span class="line"><span class="comment">// HDFS as an array (assuming time is field</span></span><br><span class="line"><span class="comment">// number 3 in a tab-separated format):</span></span><br><span class="line">errors.filter(_.contains(<span class="string">"HDFS"</span>))</span><br><span class="line">      .map(_.split(’\t’)(<span class="number">3</span>))</span><br><span class="line">      .collect()</span><br></pre></td></tr></table></figure><p>在第一个对errors进行动作操作之后，Spark将在内存中村塾errors的各分区，这极大地加快了下游的计算操作。注意，最原始的RDD，lines，不会加载到RAM中。这是可取的，因为错误消息可能只是数据的一小部分（小到足够放进内存）。</p><p><img src="https://puui.qpic.cn/fans_admin/0/3_1359855289_1557060102174/0" alt></p><p>最后为了说明模型是如何实现容错的，图1展示了该RDDs的lineage图。在这次查询中，我们首先对lines进行过滤得到errors，然后在运行collect操作前进行更进一步的filter和map操作。Spark调度器将会流水执行后两个转换操作并向缓存了errors分区的结点发送任务的集合来对其进行计算。除此之外，如果errors的一个分区丢失了，Spark只会在相关的lines分区上进行过滤操作来重建丢失的分区。</p><p><img src="https://puui.qpic.cn/fans_admin/0/3_1359855289_1557060116532/0" alt></p><h3 id="2-3-RDD模型的优势"><a href="#2-3-RDD模型的优势" class="headerlink" title="2.3 RDD模型的优势"></a>2.3 RDD模型的优势</h3><p>为了理解RDDs作为分布式内存抽象的优势，表1将其与分布式共享内存（DSM）进行了比较。在DSM系统中，应用对全局地址空间进行随意位置的读写。请注意，根据此定义，我们不仅包含了传统的共享内存系统[24]，还包括应用可以进行细粒度写共享状态的其他系统，如Piccolo[27]，其提供共享DHT和分布式数据库。DSM是非常通用的抽象，但是这样的通用性使其很难以一种高效且容错的方式运用在商业集群上。</p><p>RDDs与DSM的主要不同是，RDDs只能通过粗粒度的转换操作产生（“写”），而DSM允许在内存中任意位置读写【注意对RDDs的读仍然可以是细粒度的。例如，应用系统可以将一个RDD视为一个大型只读查找表】。这会限制RDDs为执行批量写入的应用程序，但是这使得其具有高效的容错性。特别是，RDD不需要产生检查点（checkpoint）的开销，因为它们可以使用lineage来恢复【在一些应用中，在具有很长lineage链的RDDs中仍然可以使用checkpoint技术，我们将在5.4节讨论。但是，这些可以在后台完成，因为RDDs是不可变的，并且不需要像在DSM中那样保留整个应用程序的快照】。而且，只有丢失的RDD分区才需要在失败时重新计算，并且它们可以在不同的节点上并行计算，而不必回滚整个程序。</p><p>RDDs的第二个优势是，由于它们不可变的特性，通过运行缓慢任务的副本来缓解慢结点对系统拖拽的压力，就和MapReduce一样[10]。使用DSM很难实现备份任务，因为任务的两个副本将访问相同的内存位置并干扰彼此的更新。</p><p>最后，RDDs提供了DSM没有的两个其他好处。其一，在对RDDs的批量操作中，一个运行时可以基于数据的位置进行任务调度以提高性能。其二，当没有足够的内存来存储RDDs时，它就会优雅地降级，使它们仅用于扫描操作。不适合RAM的分区可以存储在磁盘上，并提供与当期数据并行系统类似的性能。</p><h3 id="2-4-不适合RDDs的应用"><a href="#2-4-不适合RDDs的应用" class="headerlink" title="2.4 不适合RDDs的应用"></a>2.4 不适合RDDs的应用</h3><p>正如引言中所讨论的，RDDs非常适用于对数据集中所有元素进行相同操作的批处理应用。在这些情况下，RDDs可以有效地将每个转换（transformations）记录为lineage图中的一个步骤，并且可以在不记录大量数据的情况下恢复丢失的分区。RDDs不太适合对共享状态进行异步细粒度共享状态更新的应用程序，例如Web应用程序的存储系统或增量Web爬网程序。对于这些应用程序，使用执行传统更新日志记录和checkpoint的系统更有效，例如数据库，RAMCloud [25]，Percolator [26]和Piccolo [27]。我们的目标是为批量分析提供高效的编程模型，并将这些异步应用程序留给专用系统。我们的目标是为批量分析提供高效的编程模型，并将这些异步应用程序留给专用系统。</p><h2 id="3-Spark编程接口"><a href="#3-Spark编程接口" class="headerlink" title="3 Spark编程接口"></a>3 Spark编程接口</h2><p>Spark通过Scala [2]提供类似于DryadLINQ [31]语言集成API的RDDs抽象，Scala [2]是基于Java VM的静态类型函数编程语言。我们之所以选择Scala，是因为它结合了简洁（便于交互使用）和效率（静态类型）。但是，关于RDD抽象的任何内容都不需要函数式语言</p><p><img src="https://puui.qpic.cn/fans_admin/0/3_1359855289_1557060128798/0" alt></p><p>要使用Spark，开发人员编写一个连接到一组workers的driver程序，如图2所示。驱动程序定义一个或多个RDDs并在其上调用动作操作。驱动程序上的Spark代码也会追踪RDDs的lineage。这些workers是长期存在的过程，能够跨操作在RAM中存储RDDs分区。</p><p>正如我们在2.2.1中的日志挖掘例子中所展示，用户想如map这样的RDD操作传递闭包（函数形式）来提供参数。Scala将每个闭包表示为Java对象，这些对象可以序列化并加载到另一个节点上，以通过网络传递闭包。Scala也将在闭包中绑定的任何变量作为Java对象的域。比如，可以编写代码：var x = 5; rdd.map(_ + x)，将在RDD中的每一个元素都加5【我们在闭包创建时对其进行保存，这样例子中的map操作永远都是加5，即使x发生变化】。</p><p>RDD本身是由元素类型参数化的静态类型对象。例如，RDD [Int]是整数的RDD。但是，由于Scala支持类型推断，因此我们的大多数示例都省略了类型。</p><p>虽然我们在Scala中暴露RDDs的方法在概念上很简单，但我们必须使用反射解决Scala的闭包对象的问题[33]。我们还需要更多的工作来使Spark可以使用Scala解释器，我们将在5.2节中讨论。但是，我们不必修改Scala编译器。</p><h3 id="3-1-Spark中的RDD操作"><a href="#3-1-Spark中的RDD操作" class="headerlink" title="3.1 Spark中的RDD操作"></a>3.1 Spark中的RDD操作</h3><p><img src="https://puui.qpic.cn/fans_admin/0/3_1359855289_1557060140749/0" alt></p><p>表2列出了Spark中可用的主要RDD转换和动作操作。我们给出每个操作的签名，在方括号中显示类型参数。再次强调转换（transformations）是定义新RDD的延迟操作，而动作（actions）启动计算将向程序返回值或将数据写入外部存储。</p><p>请注意，某些操作（如join）仅适用于键值对的RDDs。此外，我们的函数名称被选择为与Scala和其他函数式语言中的其他API匹配；例如，map是一对一映射，而flatMap将每个输入值映射到一个或多个输出（类似于MapReduce中的映射）。</p><p>除了这些运算符，用户还可以持久化RDD。此外，用户可以获得RDD的分区顺序（由Partitioner类表示），并根据它对另一个数据集进行分区。诸如groupByKey，reduceByKey和sort操作自动地会产生哈希或范围分区的RDD。</p><h3 id="3-2-示例应用"><a href="#3-2-示例应用" class="headerlink" title="3.2 示例应用"></a>3.2 示例应用</h3><p>我们使用两个迭代应用程序补充了2.2.1节中的数据挖掘示例：逻辑回归和PageRank。后者还展示了如何控制RDD的分区以提高性能。</p><h4 id="3-2-1-logistic回归"><a href="#3-2-1-logistic回归" class="headerlink" title="3.2.1 logistic回归"></a>3.2.1 logistic回归</h4><p>许多机器学习算法本质上是迭代的，因为它们运行迭代优化过程，例如梯度下降，以最大化功能。因此，通过将数据保存在内存中，以更快地运行。</p><p>例如，以下程序实现了逻辑回归[14]，这是用于搜索最能分开两类点（例如，垃圾邮件和非垃圾邮件）的超平面w的一个通用算法。该算法使用梯度下降：它以随机值开始w，并且在每次迭代时，它将w的函数与数据相加以沿着改善它的方向移动。</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> points = spark.textFile(...)</span><br><span class="line">                  .map(parsePoint).persist()</span><br><span class="line"><span class="keyword">var</span> w = <span class="comment">// random initial vector</span></span><br><span class="line"><span class="keyword">for</span> (i &lt;- <span class="number">1</span> to <span class="type">ITERATIONS</span>) &#123;</span><br><span class="line">  <span class="keyword">val</span> gradient = points.map&#123; p =&gt;</span><br><span class="line">    p.x * (<span class="number">1</span>/(<span class="number">1</span>+exp(-p.y*(w dot p.x)))<span class="number">-1</span>)*p.y</span><br><span class="line">  &#125;.reduce((a,b) =&gt; a+b)</span><br><span class="line">  w -= gradient</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们首先定义一个名为points的持久RDD作为文本文件上的map转换的结果，该文本文件将每行文本解析为Point对象。然后，我们通过对当前w的函数求和，对points重复运行map和reduce以计算每一步的梯度。在迭代的过程中将points保存在内存中可以获得20倍的加速，这将在6.1节展示。</p><h4 id="3-2-2-PageRank"><a href="#3-2-2-PageRank" class="headerlink" title="3.2.2 PageRank"></a>3.2.2 PageRank</h4><p>更复杂的数据共享模式发生在PageRank [6]。算法通过累加在文件中对每个文件的应用次数迭代地更新每一文件的rank。在每次迭代时，每个文件都向其邻居发送r/n的贡献值，r是其排名，n是其邻居的数量。然后通过α/N + (1 − α)∑ci式子更新排名，其中求和是它所收到的贡献值，而N是文件的总数。我们可以通过如下代码Spark中实现PageRank：</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Load graph as an RDD of (URL, outlinks) pairs</span></span><br><span class="line"><span class="keyword">val</span> links = spark.textFile(...).map(...).persist()</span><br><span class="line"><span class="keyword">var</span> ranks = <span class="comment">// RDD of (URL, rank) pairs</span></span><br><span class="line"><span class="keyword">for</span> (i &lt;- <span class="number">1</span> to <span class="type">ITERATIONS</span>) &#123;</span><br><span class="line"><span class="comment">// Build an RDD of (targetURL, float) pairs</span></span><br><span class="line">  <span class="comment">// with the contributions sent by each page</span></span><br><span class="line">  <span class="keyword">val</span> contribs = links.join(ranks).flatMap &#123;</span><br><span class="line">    (url, (links, rank)) =&gt;</span><br><span class="line">      links.map(dest =&gt; (dest, rank/links.size))</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// Sum contributions by URL and get new ranks</span></span><br><span class="line">  ranks = contribs.reduceByKey((x,y) =&gt; x+y)</span><br><span class="line">             .mapValues(sum =&gt; a/<span class="type">N</span> + (<span class="number">1</span>-a)*sum)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://puui.qpic.cn/fans_admin/0/3_1599777765_1557060154806/0" alt></p><p>该程序产生图3中的RDD lineage图。在每次迭代中，我们基于来自先前的迭代的contribs和ranks以及静态links数据集来创建新的排名数据集【请注意，尽管RDD是不可变的，但程序中的变量rank和contribs指向每次迭代时的不同RDDs】。图3的一个有趣特征是随着迭代数目的增加而不断增长。因此，在具有多次迭代的作业中，可能需要可靠地复制某些版本的ranks以减少故障恢复时间[20]。用户可以使用RELIABLE标志调用persist来执行此操作。但请注意，不需要复制links数据集，因为可以通过在输入文件的块上重新运行map来有效地重建它的分区。此数据集通常比ranks大得多，因为每个文档都有许多链接，但只有一个数字作为其排名，因此使用lineage恢复它比使用checkpoint回复程序整个内存中状态的系统更节省时间。</p><p>最后，我们可以通过控制RDDs的分区来优化PageRank中的通信。如果我们指定links的分区（例如，通过节点间的URL对link lists进行哈希分区），以相同的方式对ranks进行分区，这样就确保links和ranks之间的join操作不需要通信（因为每个URL的排名将与其link list在同一台机器上）。我们还可以编写自定义分区程序类来对相互链接的页面进行分组（例如，按域名对URL进行分区）。在定义links时，可以通过调用partitionBy来表示这两种优化：</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">links = spark.textFile(...).map(...)</span><br><span class="line">             .partitionBy(myPartFunc).persist()</span><br></pre></td></tr></table></figure><p>在此初始化之后，links和ranks之间的join操作会自动地将每个URL的贡献值聚集到它link lists所在的机器上，在这台机器上计算新的排名并与它的links进行join操作。这种跨迭代的一致分区是Pregel等专用框架中的主要优化之一。 RDDs让用户直接表达这一目标。</p><h2 id="4-表示RDDs"><a href="#4-表示RDDs" class="headerlink" title="4 表示RDDs"></a>4 表示RDDs</h2><p>提供RDD作为抽象的挑战之一是为它们选择一种能够跟踪各种转换操作的lineage的表示。理想情况下，实现RDD的系统应该提供尽可能丰富的一组转换操作（例如，表2中的转换操作），并让用户以任意方式组合它们。我们为RDD提出了一个简单的基于图的表示，以达到这些目标。我们在Spark中使用这种表示来支持各种转换，而无需为调度器添加针对每个转换的特殊逻辑，这大大简化了系统设计。简而言之，我们建议通过一个公共接口来表示每个RDD，这个接口包含五条信息：一组分区，它们是数据集的原子部分；父RDDs（parent RDDs）的一组依赖关系；基于其父RDDs计算数据集的函数；有关其分区方案和数据放置的元数据。例如，表示HDFS文件的RDD具有文件的每个块的分区，并且知道每个块所在的机器。同时，对于这个RDD进行map操作的结果具有相同的分区，但是在计算其元素时将在父数据上应用map方法。我们在表3中总结了这个接口。</p><p><img src="https://puui.qpic.cn/fans_admin/0/3_234219102_1557060167174/0" alt></p><p>设计此接口时最有趣的问题是如何表示RDDs之间的依赖关系。我们发现将依赖关系分为两类是足够且有用的：窄依赖关系（narrow dependencies），其中父RDD的每个分区最多由子RDD的一个分区使用；宽依赖关系（wide dependencies），其中多个子RDD分区可能依赖一个父DD分区。例如，map导致窄依赖关系，而join导致宽依赖关系（除非父RDD是哈希分区的）。图4显示了其他示例。</p><p><img src="https://puui.qpic.cn/fans_admin/0/3_256675758_1557060251325/0" alt></p><p>这样区分有两个原因。首先，窄依赖关系允许在一个集群节点上进行流水线执行，这可以计算所有父分区。例如，可以逐个元素地应用map，然后应用filter操作。相比之下，宽依赖关系要求所有父分区的数据都已经计算完成，并使用类似MapReduce的操作在节点之间进行shuffle。其次，节点故障后的恢复在窄依赖时更有效，因为只需要重新计算丢失的对应的父分区，并且可以在不同节点上并行地重新计算它们。相反，在具有宽依赖的lineage图中，单个故障节点可能导致RDD的所有祖先丢失某些分区，从而需要完全重新执行计算。</p><p>RDDs的这个通用接口使得可以在少于20行代码中实现Spark中的大多数转换操作。实际上，即使是新的Spark用户也已经实现了新的转换（例如，采样和各种类型的join），而不用知道调度器的细节。我们在下面阐述一些RDD实现。</p><p><strong>HDFS文件：</strong><br>我们样本中的输入RDDs是HDFS中的文件。对于这些RDDs，partitions为文件的每个块返回一个分区（块的偏移量存储在每个Partition对象中），preferredLocations给出块所在的节点，iterator读取块。</p><p><strong>map：</strong><br>在任何RDD上调用map都会返回MappedRDD对象。该操作传递一个函数参数给map，对父RDD上的记录按照iterator的方式执行这个函数，并返回一组符合条件的父RDD分区及其位置。</p><p><strong>union：</strong><br>在两个RDD上执行union操作，返回两个父RDD分区的并集。通过相应父RDD上的窄依赖关系计算每个子RDD分区【7注意union操作不会过滤重复值】。</p><p><strong>join：</strong><br>对两个RDD执行join操作可能产生窄依赖（如果这两个RDD拥有相同的哈希分区或范围分区），可能是宽依赖，也可能两种依赖都有（比如一个父RDD有分区，而另一父RDD没有）。在任何一种情况下，输出RDD都有一个分区程序（从父项继承的分区程序或默认的散列分区程序）。</p><h2 id="5-实现"><a href="#5-实现" class="headerlink" title="5 实现"></a>5 实现</h2><p>我们大约用14000行scala代码实现了Spark。该系统运行在Mesos集群管理器[17]上，允许它与Hadoop，MPI和其他应用程序共享资源。每个Spark程序作为单独的Mesos应用程序运行，具有自己的驱动程序（master）和工作程序（workers），这些应用程序之间的资源共享由Mesos管理的。Spark可以使用Hadoop现有的输入插件API从任何Hadoop输入源（例如，HDFS或HBase）读取数据，并在未经修改的Scala版本上运行。</p><p>我们现在简要介绍系统中几个技术上有趣的部分：我们的作业调度程序（第5.1节），允许交互式使用的Spark解释器（第5.2节），内存管理（第5.3节）和支持检查点（第5.4节）。</p><h3 id="5-1-作业调度"><a href="#5-1-作业调度" class="headerlink" title="5.1 作业调度"></a>5.1 作业调度</h3><p><img src="https://puui.qpic.cn/fans_admin/0/3_1359855289_1557060276767/0" alt></p><p>Spark的调度程序使用我们在第4节所述的RDD表示。</p><p>总的来说，我们的调度程序类似于Dryad的[19]，但是另外考虑了RDDs在内存中持久化的分区。每当用户在RDD上运行动作（例如，count或save）时，该调度程序就会检查该RDD的lineage图以构建要执行的stage的DAG，如图5所示。每个阶段包含尽可能多的具有窄依赖的流水线转换。阶段的边界是宽依赖所需的shuffle操作，或任何已经计算过的分区，它们可以跳过父RDD的计算。然后，调度程序启动任务以计算每个阶段中丢失的分区，直到计算出目标RDD为止。</p><p>我们的调度程序基于数据位置使用延迟调度将任务分配给机器[32]。如果任务需要处理节点内存中可用的分区，我们会将其发送到该节点。否则，如果任务处理包含RDD提供优选位置的分区（例如，HDFS文件），我们将其发送给那些分区。</p><p>对于宽依赖关系（即，shuffle依赖关系），我们目前在包含父分区的节点上物化中间记录以简化故障恢复，就像MapReduce物化map输出一样。</p><p>如果任务失败，只要其阶段的父项仍然可用，我们就会在另一个节点上重新运行它。如果某些阶段变得不可用（例如，因为来自shuffle的“map side”的输出丢失），我们重新提交任务以并行计算丢失的分区。我们还不能解决调度程序的失败，尽管复制RDD的lineage图会更简单。</p><p>最后，尽管Spark中的所有计算当前都是为响应驱动程序中调用的操作而运行的，但我们也在尝试让集群上的任务（例如，映射）调用lookup操作，其提供根据键值对哈希分区的RDDs中的元素进行随机获取。在这种情况下，任务需要告诉调度程序在缺少时计算所需的分区。</p><h3 id="5-2-解释器整合"><a href="#5-2-解释器整合" class="headerlink" title="5.2 解释器整合"></a>5.2 解释器整合</h3><p>Scala包含一个类似于Ruby和Python的交互式shell。鉴于内存数据的延迟较低，我们希望让用户从解释器主动运行Spark来查询大数据集。</p><p>Scala解释器通常通过为用户键入的每一行编译一个类，将其加载到JVM中，并在其上调用函数来操作。该类包含一个单例对象，该对象包含该行上的变量或函数，并在初始化方法中运行行代码。例如，如果用户输入代码var x = 5，接着又输入println(x)，则解释器会定义一个包含x的Line1类，并将第2行编译为println(Line1.getInstance().x)。</p><p>在Spark中我们对解释器做了两点改动：</p><p>1.类传输：解释器能够支持基于HTTP传输类字节码，这样worker节点就能获取输入每行代码对应的类的字节码。</p><p>2.改进的代码生成逻辑：通常每行上创建的单例对象通过对应类上的静态方法进行访问。也就是说，如果要序列化一个闭包，它引用了前面代码行中变量，比如上面的例子Line1.x，Java不会根据对象关系传输包含x的Line1实例。所以worker节点不会收到x。我们将这种代码生成逻辑改为直接引用各个行对象的实例。</p><p><img src="https://puui.qpic.cn/fans_admin/0/3_1379495610_1557060301153/0" alt></p><p>图6显示了在我们更改之后，解释器如何将用户键入的一组行转换为Java对象。</p><p>Spark解释器便于跟踪处理大量对象关系引用，并且便利了HDFS数据集的研究。我们计划以Spark解释器为基础，开发提供高级数据分析语言支持的交互式工具，比如SQL。</p><h3 id="5-3-内存管理"><a href="#5-3-内存管理" class="headerlink" title="5.3 内存管理"></a>5.3 内存管理</h3><p>Spark提供了三种持久化RDD的选项：反序列化Java对象的内存存储，序列化数据的内存存储和硬盘存储。第一个选项提供最快的性能，因为Java VM可以原生访问每个RDD元素。第二个选项允许用户在空间有限时选择比Java对象图更高效的内存表示，但代价是性能较低【成本取决于应用程序每个字节数据的计算量，但轻量级处理的最大值可提升2倍】。第三个选项对于太大而无法保留在RAM中但在每次使用时重新计算成本高昂的RDD非常有用</p><p>为了管理可用的有限内存，我们在RDDs层面上使用LRU替换策略。当计算新的RDD分区但没有足够的空间来存储它时，我们从最近最少的RDD中替换出一个分区，除它这与具有新分区的RDD相同。在这种情况下，我们将旧分区保留在内存中，以防止来自同一RDD的分区循环进出。这很重要，因为大多数操作都会在整个RDD上运行任务，因此很可能将来需要已经在内存中的分区。到目前为止，我们发现此默认策略在所有应用程序中都能正常运行，但我们还通过每个RDD的“持久化优先级”为用户提供进一步控制。</p><p>最后，群集上的每个Spark实例当前都有自己独立的内存空间。在未来的工作中，我们计划通过统一的内存管理器来研究跨Spark实例共享RDDs。</p><h3 id="5-4-对检查点的支持"><a href="#5-4-对检查点的支持" class="headerlink" title="5.4 对检查点的支持"></a>5.4 对检查点的支持</h3><p>尽管在故障之后可以始终使用lineage来恢复RDDs，但对于具有长lineage的RDDs来说，这种恢复可能是耗时的。因此，将一些RDDs checkpoint到稳定存储可能会有所帮助。</p><p>通常，检查点技术对于包含宽依赖关系的长lineage图的RDDs很有用，例如我们的PageRank示例（第3.2.2节）中的rank数据集。在这些情况下，集群中的节点故障可能导致每个父RDD丢失一些数据片段，从而需要完全重新计算[20]。相反，对于对稳定存储中的数据具有窄依赖的RDDs，例如我们的逻辑回归示例（第3.2.1节）中的points和PageRank中的link lists，检查点技术可能没多大用。如果节点发生故障，则可以在其他节点上并行重新计算从这些RDD中丢失的分区，而这只是复制整个RDD的成本的一小部分。</p><p>Spark目前提供了一个用于检查点技术的API（一个在persist中的REPLICATE标志），但是由用户决定哪些数据使用检查点。但是，我们还在研究如何进行自动检查。因为我们的调度程序知道每个数据集的大小以及首次计算它所花费的时间，所以它应该能够选择一组最佳RDDs来检查点以最小化系统恢复时间[30]。</p><p>最后，要强调的一点是，RDDs的只读特性使它们比通用共享存储更容易进行检查。由于一致性问题不需要考虑，因此可以在后台写出RDD，而无需程序暂停或采用分布式快照方案。</p><h2 id="6-评估"><a href="#6-评估" class="headerlink" title="6 评估"></a>6 评估</h2><p>我们通过Amazon EC2上的一系列实验以及用户应用程序的基准评估了Spark和RDDs。总的来说，我们的结果显示如下：</p><ul><li>在迭代机器学习和图形应用程序中，Spark的性能比Hadoop高出20倍。加速来自于通过将数据作为Java对象存储在内存中来避免I / O和反序列化成本。</li><li>我们的用户编写的应用程序可以很好地执行和扩展。特别是，我们使用Spark分析报表比在Hadoop上运行快40倍。</li><li>当节点发生故障时，Spark可以通过仅重建丢失的RDD分区来快速恢复。</li><li>Spark可用于交互查询1 TB数据集，延迟仅为5-7秒。</li></ul><p>我们首先与Hadoop进行迭代机器学习（第6.1节）和PageRank（第6.2节）的基准比较。然后，我们评估Spark中的故障恢复（第6.3节）以及数据集不适合存储时的行为（第6.4节）。最后，我们讨论了用户应用（第6.5节）和交互式数据挖掘（第6.6节）的结果。</p><p>除非另有说明，否则我们的测试使用m1.xlarge EC2节点，其中包含4个内核和15 GB RAM。我们使用HDFS进行存储，具有256 MB块。在每次测试之前，我们清除了OS缓冲区高速缓存，以准确测量IO成本。</p><h3 id="6-1-迭代式机器学习应用"><a href="#6-1-迭代式机器学习应用" class="headerlink" title="6.1 迭代式机器学习应用"></a>6.1 迭代式机器学习应用</h3><p>我们实现了两个迭代机器学习应用程序，逻辑回归和k-means，以比较以下系统的性能：</p><ul><li>Hadoop：The Hadoop 0.20.2 stable release。</li><li>HadoopBinMem：在首轮迭代中执行预处理，通过将输入数据转换成为开销较低的二进制格式来减少后续迭代过程中文本解析的开销，在HDFS中加载到内存。</li><li>Spark：基于RDDs的实现。</li></ul><p>我们使用25-100台机器在100 GB数据集上对这两个算法进行了10次迭代。两个应用程序之间的关键区别是它们每个数据字节执行的计算量。k-means的迭代时间由计算决定，而逻辑回归的计算密集度较低，但对反序列化和I / O花费的时间更敏感。</p><p>由于典型的学习算法需要数十次迭代才能收敛，因此我们分别报告第一次迭代和后续迭代的时间。我们发现通过RDDs共享数据可以大大加快未来的迭代速度。</p><p><img src="https://puui.qpic.cn/fans_admin/0/3_1280192908_1557060314454/0" alt></p><p><img src="https://puui.qpic.cn/fans_admin/0/3_1379495610_1557060328473/0" alt></p><p><strong>首次迭代</strong><br>所有三个系统在第一次迭代中从HDFS读取文本输入。如图7中的浅色柱状图所示，Spark在实验中比Hadoop要快一些。如图7中的灯条所示，Spark在实验中比Hadoop要快一些。HadoopBinMem是最慢的，因为它通过一个额外的MapReduce作业将数据转换成二进制格式，并必须通过网络在HDFS结点间复制数据。</p><p><strong>后续迭代</strong><br>图7还显示了后续迭代的平均运行时间，而图8显示了其随集群大小变化而产生的时间变化。对于逻辑回归，Spark在100台机器上分别比Hadoop和HadoopBinMem快25.3倍和20.7倍。对于更加计算密集型的k-means应用程序来说，Spark仍然实现了1.9倍到3.2倍的加速。</p><p><strong>理解速度提升</strong><br>我们惊讶地发现Spark甚至比内存存储二进制数据的Hadoop（HadoopBinMem）还要快20倍。在HadoopBinMem中，我们使用了Hadoop的标准二进制格式（SequenceFile）和256 MB大小的超大块，并且我们强制HDFS的数据目录位于内存文件系统中。但是，由于以下几个因素，Hadoop仍然运行缓慢：</p><p>1.Hadoop软件堆栈的最小开销，</p><p>2.提供数据时HDFS的开销，</p><p>3.将二进制记录转换为可用的内存中Java对象的反序列化成本。</p><p>我们依次研究了这些因素。为了估测1，我们运行空的Hadoop作业，仅仅执行作业的初始化、启动任务、清理工作就至少耗时25秒。对于2，我们发现为了服务每一个HDFS数据块，HDFS进行了多次复制以及计算校验和操作。</p><p>最后，为了估测3，我们在一台机器上运行微基准测试，以256 MB输入的各种格式运行逻辑回归计算。特别是，我们比较了处理来自HDFS（HDFS堆栈中的开销将给出）和内存本地文件（内核可以非常有效地将数据传递给程序）的文本和二进制输入的时间。</p><p><img src="https://puui.qpic.cn/fans_admin/0/3_1359855289_1557060341567/0" alt></p><p>结果如图9所示。内存中HDFS和本地文件之间的差异表明，通过HDFS读取产生了2秒的开销，即使数据存储在本地机器上也是如此。文本和二进制输入之间的差异表明解析开销为7秒。最后，即使从内存文件中读取，将预解析的二进制数据转换为Java对象也需要3秒钟，这仍然几乎与逻辑回归本身一样开销高昂。通过将RDD元素直接存储为内存中的Java对象，Spark可以避免所有这些开销。</p><h3 id="6-2-PageRank"><a href="#6-2-PageRank" class="headerlink" title="6.2 PageRank"></a>6.2 PageRank</h3><p><img src="https://puui.qpic.cn/fans_admin/0/3_1379495610_1557060351959/0" alt></p><p>我们使用54 GB Wikipedia导出数据比较了Spark与Hadoop 进行PageRank的性能。PageRank算法通过10轮迭代处理了大约400万文章的链接图数据。图10展示了单独的内存存储使Spark在30个节点上的速度比Hadoop提高了2.4倍。此外，如第3.2.2节所述，控制RDD的分区以使其在迭代中保持一致，将提高到7.4倍。加速也能几乎线性地扩展到60个节点上。</p><p>我们还评估了使用Spark实现Pregel版本的PageRank的性能，结果将在7.1节展示。迭代时间与图10中的相似，但是更长约4秒，因为Pregel在每次迭代时运行一个额外的操作，让顶点“投票”是否完成工作。</p><p><img src="https://puui.qpic.cn/fans_admin/0/3_1599777765_1557060363143/0" alt></p><h3 id="6-3-错误恢复"><a href="#6-3-错误恢复" class="headerlink" title="6.3 错误恢复"></a>6.3 错误恢复</h3><p>我们评估了k-means应用程序中节点故障后使用lineage重建RDD分区的开销。图11比较了正常操作场景中75节点集群上k-means的10次运行的运行时间，其中一个节点在第6次迭代开始时失败。另一个没有任何故障，每次迭代包含400个任务，处理100 GB的数据。</p><p>直到第5次迭代结束，迭代时间约为58秒。在第6次迭代中，其中一台机器被杀死，导致在该机器上运行的任务和存储在那里的RDD分区丢失。Spark在其他机器上并行重新执行这些任务，他们通过lineage重新读取相应的输入数据和重建的RDD，导致操作时间增加到80秒。一旦重建丢失的RDD分区，迭代时间就会回落到58秒。</p><p>请注意，使用基于检查点的故障恢复机制，恢复可能需要重新运行至少几次迭代，具体取决于检查点的频率。此外，系统需要通过网络复制应用程序的100 GB工作集（文本输入数据转换为二进制），并且要么消耗两倍于Spark的内存以将其复制到RAM中，要么必须等待写入100 GB到磁盘。相比之下，我们示例中RDD的lineage图的大小都小于10 KB。</p><h3 id="6-4-内存不足时表现"><a href="#6-4-内存不足时表现" class="headerlink" title="6.4 内存不足时表现"></a>6.4 内存不足时表现</h3><p>到现在为止，我们能保证集群中的每个节点都有足够的内存去缓存迭代过程中使用的RDDs。一个自然的问题是，如果没有足够的内存来存储作业的数据，Spark是如何运行的。在本实验中，我们将Spark配置为不使用超过一定百分比的内存来在每台机器上存储RDD。图12中，我们为的逻辑回归提供了各种存储空间的配置。我们发现性能在控件降低时缓慢降低。</p><p><img src="https://puui.qpic.cn/fans_admin/0/3_1379495610_1557060374238/0" alt></p><h3 id="6-5-用Spark构建的用户应用程序"><a href="#6-5-用Spark构建的用户应用程序" class="headerlink" title="6.5 用Spark构建的用户应用程序"></a>6.5 用Spark构建的用户应用程序</h3><p><strong>内存分析</strong><br>Conviva Inc是一家视频发行公司，它使用Spark加速了之前在Hadoop上运行的大量数据分析报告。例如，一份报告作为一系列Hive [1]查询运行，这些查询计算出了客户的各种统计信息。这些查询都在相同的数据子集上工作（与客户提供的过滤器匹配的记录），但在不同的分组字段上执行了聚合（平均值，百分位数和COUNT DISTINCT），需要使用单独的MapReduce作业。通过在Spark中实现查询并将一次共享的数据子集加载到RDD中，该公司能够将报告速度提高40倍。在Hadoop集群上花费20小时的200 GB压缩数据的报告现在仅使用两台Spark计算机就能在30分钟内运行完成。此外，Spark程序只需要96 GB的RAM，因为它只存储与RDD中客户的过滤器匹配的行和列，而不是整个解压缩文件。</p><p><strong>城市交通模型</strong><br>在Berkeley的Mobile Millennium项目[18]中，基于一系列分散的汽车GPS监测数据，研究人员使用并行化机器学习算法来推算公路交通拥堵状况。数据来自市区10000个互联的公路线路网，还有600000个由汽车GPS装置采集到的样本数据，这些数据记录了汽车在两个地点之间行驶的时间（每一条路线的行驶时间可能跨多个公路线路网）。使用一个交通模型，通过推算跨多个公路网行驶耗时预期，系统能够估算拥堵状况。研究人员使用Spark实现了一个可迭代的EM算法，其中包括向Worker节点广播路线网络信息，在E和M阶段之间执行reduceByKey操作，应用从20个节点扩展到80个节点（每个节点4核），如图13（a）所示：</p><p><img src="https://puui.qpic.cn/fans_admin/0/3_1599777765_1557060384098/0" alt></p><p><strong>推特垃圾邮件分类</strong><br>Berkeley的Monarch项目[29]使用Spark识别Twitter消息上的垃圾链接。他们在Spark上实现了一个类似6.1小节中示例的Logistic回归分类器，不同的是使用分布式的reduceByKey操作并行对梯度向量求和。图13（b）显示了基于50G数据子集训练训练分类器的结果，整个数据集是250000的URL、至少10^7个与网络相关的特征/维度，内容、词性与访问一个URL的页面相关。随着节点的增加，这并不像交通应用程序那样近似线性，主要是因为每轮迭代的固定通信代价较高。</p><h3 id="6-6-交互式数据挖掘"><a href="#6-6-交互式数据挖掘" class="headerlink" title="6.6 交互式数据挖掘"></a>6.6 交互式数据挖掘</h3><p>为了演示Spark交互式查询大数据集的能力，我们用它来分析1TB的维基百科页面浏览日志（2年的数据）。在本次实验中，我们使用了100 m2.4xlarge EC2实例，每个实例有8个内核和68 GB内存。在整个输入数据集上简单地查询如下内容以获取页面浏览总数：（1）全部页面；（2）页面的标题能精确匹配给定的关键词；（3）页面的标题能部分匹配给定的关键词。</p><p><img src="https://puui.qpic.cn/fans_admin/0/3_1359855289_1557060393080/0" alt></p><p>图14显示了分别在整个、1/2、1/10的数据上查询的响应时间，甚至1TB数据在Spark上查询仅耗时5-7秒，这比直接操作磁盘数据快几个数量级。例如，从磁盘上查询1TB数据耗时170秒，这表明了RDD缓存使得Spark成为一个交互式数据挖掘的强大工具。</p><h2 id="7-讨论"><a href="#7-讨论" class="headerlink" title="7 讨论"></a>7 讨论</h2><p>虽然RDD由于其不可变性和粗粒度转换似乎提供有限的编程接口，但我们发现它们适用于广泛的应用。特别地，RDDs可以表达数量惊人的集群编程模型，这些模型迄今已被提议作为单独的框架，允许用户在一个程序中组合这些模型（例如，运行MapReduce操作来构建图形，然后在其上运行Pregel）并在它们之间共享数据。在本节中，我们将讨论RDDs可以表达哪些编程模型以及它们如此广泛适用的原因（第7.1节）。此外，我们讨论了我们正在探索的RDDs中lineage信息的另一个好处，能够促进这些模型的调试（第7.2节）。</p><h3 id="7-1-表达现有的编程模型"><a href="#7-1-表达现有的编程模型" class="headerlink" title="7.1 表达现有的编程模型"></a>7.1 表达现有的编程模型</h3><p>RDDs可以有效地表达迄今为止独立提出的许多集群编程模型。“有效”，意味着RDDs不仅可以用于生成与这些模型中编写的程序相同的输出，而且RDDs还可以实现这些框架具有的优化，例如将特定数据保存在内存中，将其分区为最大限度地减少通信，并有效地从故障中恢复。使用RDD表达的模型包括：</p><p><strong>MapReduce：</strong> 可以使用Spark中的flatMap和groupByKey操作表示此模型，如果存在组合器，则可以使用reduceByKey表示.</p><p><strong>DryadLINQ：</strong><br>与更普遍的Dryad运行时相比，DryadLINQ系统提供了比MapReduce更广泛的运算符，但这些都是直接对应于Spark（map，groupByKey，join等）中可用的RDD转换的批量运算符。</p><p><strong>SQL：</strong><br>与DryadLINQ表达式一样，SQL查询对记录集执行数据并行操作。</p><p><strong>Pregel：</strong><br>Google的Pregel [22]是迭代图形应用程序的专用模型，起初与其他系统中的面向集合的编程模型完全不同。在Pregel中，程序作为一系列协调的“supersteps”运行。在每个supersteps中，图中的每个顶点都运行一个用户函数，可以更新与顶点相关的状态，更改图形拓扑，并将消息发送到其他顶点用于下一个superstep。该模型可以表达许多图算法，包括最短路径，二分匹配和PageRank。</p><p>让我们用RDDs实现这个模型的关键点是Pregel将相同的用户函数应用于每次迭代的所有顶点。因此，我们可以将每次迭代的顶点状态存储在RDD中，并执行批量转换（flatMap）以应用此函数并生成消息的RDD。之后可以将该RDD与顶点状态连接操作以表示消息的转换。同样重要的是，RDDs允许我们像Pregel那样将顶点状态保存在内存中，通过控制其分区来最小化通信，并支持故障时的部分恢复。我们在Spark上实现了Pregel，其作为200行库，并向读者推荐[33]以获取更多详细信息。</p><p>迭代式MapReduce： 最近提出的几个系统，包括HaLoop [7]和Twister [11]，提供了迭代的MapReduce模型，用户可以为系统提供一系列MapReduce作业循环执行。系统使数据在迭代中保持一致，Twister也可以将其保存在内存中。两种优化都很容易用RDDs表达，我们能够使用Spark将HaLoop实现为200行库。</p><p>流式批处理： 研究人员最近提出了几种增量处理系统，用于定期用新数据更新结果的应用[21,15,4]。例如，每15分钟更新一次广告点击统计数据的应用程序应该能够将前一个15分钟窗口的中间状态与新日志中的数据相结合。这些系统执行类似于Dryad的批量操作，但将应用程序状态存储在分布式文件系统中。将中间状态置于RDDs中将加速其处理。</p><p><strong><em>解释RDDs的表达性能</em></strong><br>为什么RDD能够表达这些不同的编程模型？原因是对RDD的限制对许多并行应用程序几乎没有影响。特别是，尽管RDDs只能通过批量转换创建，但许多并行程序本质上就是将相同的操作应用于许多记录，所以使其易于用RDDs表达。类似地，RDD的不变性不是一个障碍，因为可以创建多个RDD来表示同一数据集的不同版本。实际上，今天的许多MapReduce应用程序都运行在不允许更新文件的文件系统上，例如HDFS。</p><p>最后一个问题是为什么以前的框架没有提供相同的一般性。我们认为这是因为这些系统探索了MapReduce和Dryad无法很好处理的特定问题，例如迭代，但是没有观察到这些问题的常见原因是缺乏数据共享抽象。</p><h3 id="7-2-利用RDDs进行调试"><a href="#7-2-利用RDDs进行调试" class="headerlink" title="7.2 利用RDDs进行调试"></a>7.2 利用RDDs进行调试</h3><p>虽然我们最初设计的RDD在确定性方面可以重新计算以实现容错，但这个属性也可以简化调试。特别是，通过记录在作业期间创建的RDD的lineage，可以（1）稍后重建这些RDD并让用户以交互方式查询它们，以及（2）在单个过程调试中重新执行作业的任何任务，通过重新计算它所依赖的RDD分区。与通用分布式系统[13]的传统重放调试器不同，不必捕获或推断跨多节点的时间顺序，这种方法几乎不增加记录开销，因为只需要记录RDD lineage图【9 与这些系统不同，基于RDD的调试器不会重放用户函数中的非确定性行为（例如，非确定性映射），但它至少可以通过校验和数据来报告它】。我们目前正在开发基于这些想法的Spark调试器[33]。</p><h2 id="8-相关工作"><a href="#8-相关工作" class="headerlink" title="8 相关工作"></a>8 相关工作</h2><p><strong>集群编程模型：</strong><br>集群编程模型的相关工作分为几类。首先，MapReduce [10]，Dryad [19]和Ciel [23]等数据流模型支持丰富的运算符集，用于处理数据，但通过稳定的存储系统共享数据。RDDs代表比稳定存储更有效的数据共享抽象，因为它们避免了数据复制，I / O和序列化的成本【10 请注意，在像RAMCloud [25]这样的内存数据存储中运行MapReduce / Dryad仍然需要数据复制和序列化，这对于某些应用程序来说可能代价很高，如6.1节所示】。</p><p>其次，数据流系统的几个高级编程接口，包括DryadLINQ [31]和FlumeJava [8]，提供了语言集成的API，用户通过map和join等操作符操作“并行集合”。但是，在这些系统中，并行集合表示磁盘上的文件或用于表示查询计划的临时数据集。虽然系统会在相同的操作符查询间流水式地处理数据（如，一个map操作接着一个map操作），但是它们并不能在各个查询之间有效地共享数据。我们在并行收集模型上基于Spark的API，因为它的方便性，并没有增加语言集成接口的新颖性，但通过提供RDD作为此接口背后的存储抽象，我们允许它支持更广泛的应用程序。</p><p>第三类系统为需要数据共享的特定类别的应用程序提供高级接口。例如，Pregel [22]支持迭代图应用，而Twister [11]和HaLoop [7]是迭代MapReduce运行时。但是，这些框架隐式地为他们支持的计算模式提供数据共享，并且不提供一般抽象来供用户选择。例如，用户不能使用Pregel或Twister将数据集加载到内存中，然后决定在其上运行哪个查询，RDD明确地提供分布式存储抽象，因此可以支持这些专用系统不支持的应用，例如交互式数据挖掘。</p><p>最后，一些系统暴露共享可变状态以允许用户执行内存计算。例如，Piccolo [27]允许用户运行并行功能以读取和更新分布式哈希表中的单元格。分布式共享存储（DSM）系统[24]和键值存储如RAMCloud [25]提供一个相似的模型。RDD在两个方面与这些系统不同。首先，RDD基于运算符（如map，sort和join）提供更高级别的编程接口，而Piccolo和DSM中的接口只是对表格单元格的读取和更新。其次，Piccolo和DSM系统通过检查点和回滚实现恢复，这比许多应用程序中基于lineage策略的RDDs更昂贵。最后，正如第2.3节所讨论的那样，RDD还提供了其他优于DSM的优势，例如straggler缓解。</p><p><strong>缓存系统：</strong><br>Nectar [12]可以通过程序分析识别常见的子表达式，在DryadLINQ作业中重用中间结果[16]。这种能力对于添加到基于RDD的系统非常有吸引力。但是，Nectar不提供内存中缓存（它将数据放在分布式文件系统中），也不允许用户明确控制要持久化的数据集以及如何对它们进行分区。Ciel [23]和FlumeJava [8]同样可以缓存任务结果，但不提供内存缓存或显式控制缓存哪些数据。Ananthanarayanan等。建议在分布式文件系统中添加内存缓存，以利用数据访问的时间和空间局部性[3]。虽然此解决方案可以更快地访问文件系统中已有的数据，但它不像在RDDs中那样有效地在一个应用中共享中间结果，因为它仍然需要应用程序在不同阶段间将这些结果写入文件系统。</p><p><strong>Lineage：</strong><br>记载数据的lineage或起源信息长期以来一直是科学计算和数据库中的研究课题，应用于解释结果，允许数据可以被别的数据重建，同时如果在工作流中出现了bug或者数据及丢失了，能够重新计算得到数据。我们推荐读者阅读[5]和[9]来了解这些工作。RDDs提供并行编程模型，其中获取细粒度的lineage成本低廉，因此可用于故障恢复。</p><p>我们基于lineage的恢复机制也类似于MapReduce和Dryad中计算（作业）中使用的恢复机制，它跟踪任务的DAG之间的依赖关系。但是，在这些系统中，谱系（lineage）信息在作业结束后丢失，需要使用复制的存储系统来跨计算共享数据。相比之下，RDDs应用lineage来有效地跨计算保留内存数据，而无需复制和磁盘I / O的成本。</p><p><strong>关系型数据库：</strong><br>RDDs在概念上类似于数据库中的视图，而持久化RDDs类似于物化视图[28]。但是，与DSM系统一样，数据库通常允许对所有记录进行细粒度的读写访问，需要记录操作和数据以实现容错，并且需要额外的开销来维护一致性。RDD的粗粒度转换模型不需要这些开销。</p><h2 id="9-结论"><a href="#9-结论" class="headerlink" title="9 结论"></a>9 结论</h2><p>我们提供了弹性分布式数据集（RDDs），这是一种高效，通用和容错的用于在集群应用程序中共享数据的抽象。RDDs可以表达各种并行应用程序，包括已经提出用于迭代计算的许多专用编程模型，以及这些模型还未实现的新应用程序。与现有的集群存储抽象（需要数据复制以实现容错）不同，RDDs提供基于粗粒度转换的API，使其能够使用lineage来有效地恢复数据。我们在Spark中实现了RDDs，它在迭代应用程序中的性能比Hadoop高出20倍，并且可以交互式查询数百GB的数据。</p><p>我们在spark-project.org上提供了开源Spark作为可扩展数据分析和系统研究的工具。</p><h2 id="致谢"><a href="#致谢" class="headerlink" title="致谢"></a>致谢</h2><p>我们感谢第一批Spark用户，包括Tim Hunter，Lester Mackey，Dilip Joseph和Jibin Zhan，他们在实际应用中尝试我们的系统，提供了许多好的建议，并指出了一些研究中的挑战。我们还要感谢我们的指导者Ed Nightingale以及审核的反馈。这项研究部分由Berkeley AMP Lab<br>支持，由 Google, SAP, Amazon Web Services, Cloudera, <strong><em>Huawei</em></strong>, IBM, Intel, Microsoft, NEC, NetApp 和 VMWare，DARPA，the Natural Sci- ences 和 Engineering Research Council of Canada赞助。</p><h2 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h2><p>[1] Apache Hive. <a href="http://hadoop.apache.org/hive" target="_blank" rel="noopener">http://hadoop.apache.org/hive</a>.</p><p>[2] Scala. <a href="http://www.scala-lang.org" target="_blank" rel="noopener">http://www.scala-lang.org</a>.</p><p>[3] G.Ananthanarayanan,A.Ghodsi,S.Shenker,andI.Stoica.<br>Disk-locality in datacenter computing considered irrelevant. In<br>HotOS ’11, 2011.</p><p>[4] P.Bhatotia,A.Wieder,R.Rodrigues,U.A.Acar,and<br>R. Pasquin. Incoop: MapReduce for incremental computations.<br>In ACM SOCC ’11, 2011.</p><p>[5] R.BoseandJ.Frew.Lineageretrievalforscientificdata<br>processing: a survey. ACM Computing Surveys, 37:1–28, 2005.</p><p>[6] S.BrinandL.Page.Theanatomyofalarge-scalehypertextual<br>web search engine. In WWW, 1998.</p><p>[7] Y.Bu,B.Howe,M.Balazinska,andM.D.Ernst.HaLoop:<br>efficient iterative data processing on large clusters. Proc. VLDB<br>Endow., 3:285–296, September 2010.</p><p>[8] C.Chambers,A.Raniwala,F.Perry,S.Adams,R.R.Henry,<br>R. Bradshaw, and N. Weizenbaum. FlumeJava: easy, efficient<br>data-parallel pipelines. In PLDI ’10. ACM, 2010.</p><p>[9] J.Cheney,L.Chiticariu,andW.-C.Tan.Provenancein<br>databases: Why, how, and where. Foundations and Trends in<br>Databases, 1(4):379–474, 2009.</p><p>[10] J.DeanandS.Ghemawat.MapReduce:Simplifieddata<br>processing on large clusters. In OSDI, 2004.</p><p>[11] J. Ekanayake, H. Li, B. Zhang, T. Gunarathne, S.-H. Bae, J. Qiu, and G. Fox. Twister: a runtime for iterative mapreduce. In HPDC ’10, 2010.</p><p>[12] P.K.Gunda,L.Ravindranath,C.A.Thekkath,Y.Yu,and L. Zhuang. Nectar: automatic management of data and computation in datacenters. In OSDI ’10, 2010.</p><p>[13] Z.Guo,X.Wang,J.Tang,X.Liu,Z.Xu,M.Wu,M.F. Kaashoek, and Z. Zhang. R2: an application-level kernel for record and replay. OSDI’08, 2008.</p><p>[14] T.Hastie,R.Tibshirani,andJ.Friedman.TheElementsof Statistical Learning: Data Mining, Inference, and Prediction. Springer Publishing Company, New York, NY, 2009.</p><p>[15] B.He,M.Yang,Z.Guo,R.Chen,B.Su,W.Lin,andL.Zhou. Comet: batched stream processing for data intensive distributed computing. In SoCC ’10.</p><p>[16] A.Heydon,R.Levin,andY.Yu.Cachingfunctioncallsusing precise dependencies. In ACM SIGPLAN Notices, pages 311–320, 2000.</p><p>[17] B.Hindman,A.Konwinski,M.Zaharia,A.Ghodsi,A.D. Joseph, R. H. Katz, S. Shenker, and I. Stoica. Mesos: A platform for fine-grained resource sharing in the data center. In NSDI ’11.</p><p>[18] T.Hunter,T.Moldovan,M.Zaharia,S.Merzgui,J.Ma,M.J. Franklin, P. Abbeel, and A. M. Bayen. Scaling the Mobile Millennium system in the cloud. In SOCC ’11, 2011.</p><p>[19] M. Isard, M. Budiu, Y. Yu, A. Birrell, and D. Fetterly. Dryad: distributed data-parallel programs from sequential building blocks. In EuroSys ’07, 2007.</p><p>[20] S.Y.Ko,I.Hoque,B.Cho,andI.Gupta.Onavailabilityof intermediate data in cloud computations. In HotOS ’09, 2009.</p><p>[21] D. Logothetis, C. Olston, B. Reed, K. C. Webb, and K. Yocum. Stateful bulk processing for incremental analytics. SoCC ’10. [22] G.Malewicz,M.H.Austern,A.J.Bik,J.C.Dehnert,I.Horn,<br>N. Leiser, and G. Czajkowski. Pregel: a system for large-scale<br>graph processing. In SIGMOD, 2010.</p><p>[23] D.G.Murray,M.Schwarzkopf,C.Smowton,S.Smith,<br>A. Madhavapeddy, and S. Hand. Ciel: a universal execution<br>engine for distributed data-flow computing. In NSDI, 2011. </p><p>[24] B.NitzbergandV.Lo.Distributedsharedmemory:asurveyof<br>issues and algorithms. Computer, 24(8):52 –60, Aug 1991. </p><p>[25] J.Ousterhout,P.Agrawal,D.Erickson,C.Kozyrakis,<br>J. Leverich, D. Mazie`res, S. Mitra, A. Narayanan, G. Parulkar, M. Rosenblum, S. M. Rumble, E. Stratmann, and R. Stutsman. The case for RAMClouds: scalable high-performance storage entirely in DRAM. SIGOPS Op. Sys. Rev., 43:92–105, Jan 2010.</p><p>[26] D.PengandF.Dabek.Large-scaleincrementalprocessingusing distributed transactions and notifications. In OSDI 2010.</p><p>[27] R.PowerandJ.Li.Piccolo:Buildingfast,distributedprograms with partitioned tables. In Proc. OSDI 2010, 2010.</p><p>[28] R.RamakrishnanandJ.Gehrke.DatabaseManagement Systems. McGraw-Hill, Inc., 3 edition, 2003.</p><p>[29] K.Thomas,C.Grier,J.Ma,V.Paxson,andD.Song.Designand evaluation of a real-time URL spam filtering service. In IEEE Symposium on Security and Privacy, 2011.</p><p>[30] J.W.Young.Afirstorderapproximationtotheoptimum checkpoint interval. Commun. ACM, 17:530–531, Sept 1974.</p><p>[31] Y.Yu,M.Isard,D.Fetterly,M.Budiu,U ́.Erlingsson,P.K. Gunda, and J. Currey. DryadLINQ: A system for general-purpose distributed data-parallel computing using a high-level language. In OSDI ’08, 2008.</p><p>[32] M.Zaharia,D.Borthakur,J.SenSarma,K.Elmeleegy,<br>S. Shenker, and I. Stoica. Delay scheduling: A simple technique for achieving locality and fairness in cluster scheduling. In EuroSys ’10, 2010.</p><p>[33] M.Zaharia,M.Chowdhury,T.Das,A.Dave,J.Ma,<br>M. McCauley, M. Franklin, S. Shenker, and I. Stoica. Resilient distributed datasets: A fault-tolerant abstraction for in-memory cluster computing. Technical Report UCB/EECS-2011-82, EECS Department, UC Berkeley, 2011.</p>]]></content>
      
      
      <categories>
          
          <category> 毕业设计 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Spark </tag>
            
            <tag> RDD </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>翻译-新手向大型网络应用扩展</title>
      <link href="/2019/04/09/transfer-scaling-webapps-for-newbs-and-non-techies/"/>
      <url>/2019/04/09/transfer-scaling-webapps-for-newbs-and-non-techies/</url>
      
        <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>上个星期就准备翻译出这篇文章来着，但是毕设答辩加上清明节假期就导致拖到了今天。</p><p>话不多说，这篇文章是在阮一峰老师的每周记录中看到的。因为之前看了顶天的《大型网络扩展和JAVA中间件》这本书（2/3），所以对这个话题比较熟悉。加上这篇外文有很好看的插图，清晰易懂，没有技术性的阅读障碍，是通过逻辑性的思维进行网站应用扩展的讲解，所以我把它翻译出来，复习使用。</p><ul><li>原文地址: <a href="https://arcentry.com/blog/scaling-webapps-for-newbs-and-non-techies/" target="_blank" rel="noopener">Scaling webapps for newbs &amp; non-techies</a></li></ul><h2 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h2><p><img src="https://wx4.sinaimg.cn/mw1024/6a49516fly1g1web0xb1ej20zk0k0wrd.jpg" alt></p><p>这篇入门总结了将单服务器扩展到百万级别用户大型网站<strong>扩展</strong>的基本原则。这篇文章针对的是，技术领域的新手或者非开发人员的，所以如果你正在部署更高大上的应用服务的话，这篇文章并不适合你。</p><p>如果这正是你想要的，那么开始吧。</p><h3 id="什么是扩展"><a href="#什么是扩展" class="headerlink" title="什么是扩展"></a>什么是扩展</h3><p>你把你编写的网站，网上商店、社交网络等，部署上线，一切都运行的很美好：每天都有几百用户访问、请求响应及时、调用立即完成。一切都有条不紊地不断运行。</p><p>但是一些”不好”的事情发生了：你大获成功！</p><p>几百、上千、上万的用户每时每秒不断涌入，并且在不断增加。这看起来是商业上最棒的消息了，但同时也在对你的基础设施（服务）说：亲爱的，你大事不妙。因为对于网站的服务来说必须要扩展了，因为它能够：</p><ul><li>同时为更多的用户提供服务</li><li>全天在线，不停机</li><li>服务全世界用户</li></ul><h3 id="扩展是怎么工作的"><a href="#扩展是怎么工作的" class="headerlink" title="扩展是怎么工作的"></a>扩展是怎么工作的</h3><p>以前，这篇文章要以讨论”纵向”扩展（”vertical”）和”横向”（”horizontal”）扩展来开头。总之，纵向扩展指的是在更强大的机器上运行相同的应用，而横向扩展是并行运行多个服务进程。</p><p>现在，已经没有人纵向扩展了，理由如下：</p><ul><li>计算机的价格和性能成指数增加的关系</li><li>单机可以运行很快，但是在纵向上的扩展是有极限的</li><li>多核CPU意味着单机也能有效的并行运算，那不如一开始就并行化好了</li></ul><p>那么横向扩展的必要步骤有那些呢？</p><h3 id="1-单服务器-数据库"><a href="#1-单服务器-数据库" class="headerlink" title="1. 单服务器+数据库"></a>1. 单服务器+数据库</h3><p><img src="https://wx1.sinaimg.cn/mw1024/6a49516fly1g1webi6rjsj20jg0bumy3.jpg" alt><br>你的网站后端可能一开始就是这个样子的。一个应用服务器执行你的业务逻辑，数据库存储数据。事情简单而美好，但是想要其高可用，只能用更好的机器–这并不好。</p><h3 id="2-增加反向代理"><a href="#2-增加反向代理" class="headerlink" title="2. 增加反向代理"></a>2. 增加反向代理</h3><p><img src="https://wx3.sinaimg.cn/mw1024/6a49516fly1g1webuwgw7j20jg0al3zf.jpg" alt></p><p>为了使你的架构能够适应更大的扩展，第一步要加一个”反向代理”。它就相当于酒店的前台。当然，你可以让客人直接去自己的房间；但是，你真正需要的事一个中间人，能够确认这位客人是否允许进入、到底有没有订房或者正去往一个正确房间的路上。同时你还要要告知客户，他要的房间可不可用、能不能去，以免尴尬的徘徊。以上就是反向代理的工作。代理就是用来接收和转发请求的。通常情况下，请求是从我们的服务器发出到互联网上的。但是这次，是从互联网上路由到我们的服务器上，所以我们”反向代理”。</p><p>一个代理需要完成以下任务：</p><ul><li>运行状态检查，确保我们的服务器还在运行</li><li>将请求路由（定向）到正确的终点</li><li>认证，确保请求的发送方是有许可的</li><li>防火墙，确保请求方访问的是服务器上有权限的内容</li></ul><h3 id="3-引入负载均衡"><a href="#3-引入负载均衡" class="headerlink" title="3. 引入负载均衡"></a>3. 引入负载均衡</h3><p><img src="https://wx2.sinaimg.cn/mw1024/6a49516fly1g1wec96qloj20jg0csabd.jpg" alt></p><p>许多反向代理还能够负载均衡。负载均衡器是一个很简单的概念：想象一下，在一分钟内有一百个用户要向你的网上商店付款，很不幸的是，你的支付系统只能同时处理50个支付请求。怎么解决？同时运行两个支付系统服务器。</p><p>现在负载均衡器的作用就是将支付请求分摊到这两个服务器上，用户1到左边的服务器，用户2区右边的服务器，用户3去左边的…以此类推。</p><p>如果同时🈶500个支付请求怎么办呢？加到10个支付系统服务器，然后用负载均衡分摊请求。</p><h3 id="4-扩展数据库"><a href="#4-扩展数据库" class="headerlink" title="4. 扩展数据库"></a>4. 扩展数据库</h3><p><img src="https://wx2.sinaimg.cn/mw1024/6a49516fly1g1wecqv3woj20jg0bwdh3.jpg" alt></p><p>运用负载均衡可以将压力分在各个服务器上。但是你发现问题了么？虽然我们可能有成百上千个服务器，用来处理请求，但是只有一个数据库存取数据。</p><p>所以，我们可以以同样的方式来扩展数据库嘛？很不幸的是，不行。关键在于一致性的问题。我们系统中的每个部分都要确保使用数据的一致性。不一致的数据导致各种棘手的问题：订单为重复执行2次，从余额100的账户里扣除2次90元的付款等等。所以我们怎样才能扩展数据库，同时又保证数据的一致性呢?</p><p>首先我们要把数据库分成不同的部分。一部分专门用来接收和存储数据，其他部分专门用来读取数据。这种方案有时称为主/从魔石，有时称为使用只读副本写入。而且假定服务器读数据比写数据的次数更多。<br>这样的解决方法就能保证一致性，因为数据是从单个接口写入的，而且数据流动是单向的，从写到读。<br>缺点就是数据输入还是由单个数据库完成，这对于中小型的应用来说是OK的，但是对于像Facebook那样级别的就不行。更进一步的数据库扩展将在之后讨论。</p><h3 id="5-微服务"><a href="#5-微服务" class="headerlink" title="5. 微服务"></a>5. 微服务</h3><p><img src="https://wx1.sinaimg.cn/mw1024/6a49516fly1g1wed4e3tyj20jg0c3tag.jpg" alt></p><p>到现在，我们都用一个服务器去完成所有的工作：处理支付、订单、库存、提供web服务、管理用户账号等。</p><p>这未必不是一件坏事，单个服务器意味着更低的复杂度（结构上的），对我们开发者来说没那么头疼。<br>但是随着扩展的增加，事情开始变得复杂和低效：</p><ul><li>不同的服务用在不同的范围。对于用户登录这个流程，可能在很多页面都有，涉及到很多的资源。但是这一些都是在一个服务器上完成的。</li><li>我们的代发团队随着应用而成长。但是越来越多的开发者在一个服务器上工作，不可避免的就会干扰到别人。</li><li>所有服务都在一起，意味着每次发新版都要将所有服务都停掉。这会导致一个很严重的相互依赖关系，一个团队已经做完了，等着发布上线，但是另一个团队可能才完成一半。</li></ul><p>解决这个问题的方法是一个结构范式，它已经掀起了开发界的一大浪潮：微服务。思想很简单，将服务器分成多个功能单元，将他们部署成独立的、互联的迷你服务器。<br>这样做有几大好处：</p><ul><li>每个服务都可以独立扩展，让我们能够机动的适应新需求。</li><li>每个开发团队独立开发，对自己的微服务生命周期负责（创建、部署、更新等）</li><li>每个微服务运用自己的资源，如数据库（一定程度上缓解了4中的问题）</li></ul><h3 id="6-缓存和内容分发网络CDN"><a href="#6-缓存和内容分发网络CDN" class="headerlink" title="6. 缓存和内容分发网络CDN"></a>6. 缓存和内容分发网络CDN</h3><p><img src="https://wx1.sinaimg.cn/mw1024/6a49516fly1g1wedhmbk3j20jg0c876a.jpg" alt></p><p>怎么才能工作更高效呢？不要什么都干！<br>我们的web应用很大一部分都是静态资源，像图片、js脚本、css文件、预渲染的进入页面等。<br>所以相比较每次都重新请求数据资源，我们不如将一些结果放在简单的缓存之中，谁需要就去拿，不用干扰到后面的服务器。</p><p>缓存的大哥叫内容分发网络CDN，是一组分布在全世界范围内的缓存。这让我们能够从用户就近的节点向他们分发内容，不需要每次都翻山越岭了。</p><h3 id="7-消息队列"><a href="#7-消息队列" class="headerlink" title="7. 消息队列"></a>7. 消息队列</h3><p><img src="https://wx3.sinaimg.cn/mw1024/6a49516fly1g1wedx2oaxj20jg0bdjtb.jpg" alt></p><p>你去过游乐园吗？你是不是每次都直接去售票厅就能买到票呢？大部分情况都要排队吧应该。<br>政府机构、邮局和游乐园都是”sub-capacity parallelism”很好的例子。他们是并行的–多个售票厅同时售票。<br>但是貌似不可能有足够的售票厅能让每个人都能立即买到票，所以队列就形成了。</p><p>在大型网站上同样可以套用这个概念。成千上万的图片每时每刻上传到Instagram、Facebook上面，每张图片都要被处理、调整、分析和打标，这是一个耗时的过程。<br>所以为了使用户不用等待所有流程都结束，服务器接收到图片之后，只完成下面3件事：</p><ul><li>存储原始图像数据</li><li>告诉用户上传成功了</li><li>向一个大堆增加虚拟标签，说明接下来需要做些什么</li></ul><p>接下来这些标签会被许多的服务器拿到，这些服务器会完成标签上需要完成的任务，确认之后再返回标签，直到所有的任务都完成。<br>系统将这一堆标签叫做”消息队列”，运用这个队列有几大好处：</p><ul><li><p>它将任务和处理器解耦。有时许多图片需要处理，有时很少；有时有很多可以进行处理的节点，有时可用的很少。<br>通过在代办事务中增加任务标签的形式，而不是直接送过去处理，可以保证我们的系统是响应的，且没有任务丢失。</p></li><li><p>它使我们能够按需扩展。因为启动服务器是耗时的，如果已经有很多用户上传了图片需要处理，而图片是直接传给服务器的，那么再启动等多的服务器就已经迟了。相反，如果我们有消息队列，就可以扩展处理能力来处理那些需要处理的任务。</p></li></ul><hr><p>👌如果我们的系统已经经过了以上的扩展，那么已经可以应对大流量了。但是如果我们想要更大更强呢？以下是几个选项。</p><h3 id="8-分片-分区"><a href="#8-分片-分区" class="headerlink" title="8. 分片/分区"></a>8. 分片/分区</h3><p><img src="https://wx4.sinaimg.cn/mw1024/6a49516fly1g1wee9hj6jj20jg0bf401.jpg" alt></p><p>什么是分区？定义如下：</p><p>“Sharding是一种通过将应用程序的堆栈分成多个单元来并行化应用程序堆栈的技术，每个单元负责某个键或命名空间”</p><p>额，所以到底什么是分区？其实很简单：需要访问20亿Facebook用户的档案，那就把Facebook分成26个小Facebook，每个Facebook服务不同姓名首字母大写的用户。</p><p>分区不一定按照首字母划分，可以是地区、使用频率（头部用户给更好的服务）等。<br>你可以将服务器分区、数据库分许，或者任何你应用系统中的一个方面，只要满足你的需求。</p><h3 id="9-对负载均衡器进行负载均衡"><a href="#9-对负载均衡器进行负载均衡" class="headerlink" title="9. 对负载均衡器进行负载均衡"></a>9. 对负载均衡器进行负载均衡</h3><p><img src="https://wx4.sinaimg.cn/mw1024/6a49516fly1g1weelr6h4j20jg0bf403.jpg" alt></p><p>单个负载均衡器只能做那么多，即使你购买超贵超牛的负载均衡器，性能都是有瓶颈的。</p><p>很幸运的是，有一个全球性的、分散的、超级稳定的层次，能够在流量到达负载均衡器之前进行分流操作。那就是”域名系统”，DNS。全球域名注册表将”github.com”映射到”XXX.XXX.XXX.XXX”这个IP地址上，同时也允许我们将特定域名映射到多个IP地址上，这样就能到达多个不同的负载均衡器了。</p><hr><p>好了，我们做的已经很多了，希望这篇对你有所帮助。但是如果你是IT行业的一员，那么你肯定会问，”到底啥是云服务？”</p><h3 id="云计算和ServerLess（无服务器）"><a href="#云计算和ServerLess（无服务器）" class="headerlink" title="云计算和ServerLess（无服务器）"></a>云计算和ServerLess（无服务器）</h3><p>什么是云服务？它是对于上面提到的所有问题一个便宜又高效的解决方法，简单来说就是，别自己解决他们。</p><p>而是让云服务厂商根据你的系统和需求为你提供扩展服务，你不用考虑任何复杂的问题，不要再造轮子。</p><p>后面略…（介绍下一篇文章的东西）</p>]]></content>
      
      
      <categories>
          
          <category> 技术总结 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 翻译 </tag>
            
            <tag> 大型网络扩展 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>每周记录📝（190330）</title>
      <link href="/2019/03/30/weeklyReport190330/"/>
      <url>/2019/03/30/weeklyReport190330/</url>
      
        <content type="html"><![CDATA[<p>这周看了乔布斯的传记，其中说到乔布斯做产品的时候，追求完美。</p><p>这周把毕设完善了一下：<br><img src="https://wx1.sinaimg.cn/mw1024/6a49516fly1g1l2zafpgwj21hc0u079v.jpg" alt></p><p><img src="https://wx2.sinaimg.cn/mw1024/6a49516fly1g1l2z9yalhj21hc0u0n9a.jpg" alt></p>]]></content>
      
      
      <categories>
          
          <category> 每周记录 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Minions初始化手册✋</title>
      <link href="/2019/03/27/minionsUsage/"/>
      <url>/2019/03/27/minionsUsage/</url>
      
        <content type="html"><![CDATA[<ul><li><p>kill所有进程</p></li><li><p>启动zooKeeper</p></li></ul><p><code>zookeeper&gt;bin ./zkServer.sh start</code></p><ul><li>启动Kafka（后台）</li></ul><p><code>kafka&gt; bin/kafka-server-start.sh -daemon $KAFKA_HOME/config/server.properties</code></p><ul><li>启动两个flume<ul><li>对接Python产生的伪日志</li><li>对接前端埋点的数据</li></ul></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">//页面浏览日志 agent</span><br><span class="line">flume-ng agent \</span><br><span class="line">--name exec-memory-kafka \</span><br><span class="line">--conf $FLUME_HOME/conf \</span><br><span class="line">--conf-file /home/hadoop/data/project/streaming_project2.conf \</span><br><span class="line">-Dflume.root.logger=INFO,console</span><br><span class="line"></span><br><span class="line">//页面行为日志 agent</span><br><span class="line">flume-ng agent \</span><br><span class="line">--name agent1 \</span><br><span class="line">--conf $FLUME_HOME/conf \</span><br><span class="line">--conf-file $FLUME_HOME/conf/streaming2.conf \</span><br><span class="line">-Dflume.root.logger=INFO,console</span><br></pre></td></tr></table></figure><ul><li>启动Hadoop<ul><li>DataNode</li><li>SecondaryNameNode</li><li>NameNode </li></ul></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">hadoop/sbin&gt; ./start-dfs.sh</span><br><span class="line"></span><br><span class="line">//单独启动命令：</span><br><span class="line">./hadoop-daemon.sh start secondarynamenode</span><br></pre></td></tr></table></figure><ul><li>启动HBase<ul><li>HMaster</li><li>HRegionServer </li></ul></li></ul><p><code>bin&gt; ./start-hbase.sh</code></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">./hbase shell</span><br><span class="line"></span><br><span class="line">list</span><br><span class="line">scan &apos;table_name&apos;</span><br><span class="line">desc &apos;table_name&apos;</span><br></pre></td></tr></table></figure><ul><li>启动spark作业<ul><li>MyStreamingApp : 统计访问量</li><li>KafKaStreamingApp : 处理前端埋点数据（hello_ladygaga_topic)</li></ul></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">spark-submit --master local[<span class="number">5</span>] --jars $(echo /home/hadoop/app/hbase-<span class="number">1.2</span>.0-cdh5.7.0/lib<span class="comment">/*.jar | tr ' ' ',') --class com.chaoyue.spark.project.scala.MyStreamingApp --packages org.apache.spark:spark-streaming-kafka-0-8_2.11:2.2.0 /home/hadoop/lib/sparktrain-1.0.jar hadoop000:2181 test streamingtopic 1</span></span><br></pre></td></tr></table></figure><ul><li>启动Springboot后端和react前端</li></ul>]]></content>
      
      
      <categories>
          
          <category> 毕业设计 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>每周记录📝（190323）</title>
      <link href="/2019/03/23/weeklyReport190323/"/>
      <url>/2019/03/23/weeklyReport190323/</url>
      
        <content type="html"><![CDATA[<p><img src="https://wxt.sinaimg.cn/mw1024/6a49516fly1g1crb20idzj22c02c0b2a.jpg?tags=%5B%5D" alt="图书馆"></p><p>雨后的图书馆。</p><p>本周将毕业设计的前端后端，kafka与spark streaming进行了打通。前端页面也可展示HBase中的数据。</p><p>关于ant-d Pro，我感觉肯定是有很多坑的。慢慢踩。</p><p>对于毕设后续，下一周需要将模拟打点的页面加上，并把之前例子中的spark应用部署好，能够实现组件的动态渲染。</p><p>本周首先解决了CORS问题，其实在后端加上标签即可。我的后端其实有一两点，首先是数据可视化的作用，另一个是模拟前端打点的应用。没有办法，只能这样用，模拟真实情况的服务。</p><p>另外注意到Nginx，学习到其有两个作用：反向代理+负载均衡，以后用到在深入吧。</p><p>对于HBase的scan操作，还需要深入学习一下。</p><p><img src="https://wx2.sinaimg.cn/mw1024/6a49516fly1g1cr9q61ixj21hc0u0n20.jpg" alt></p><p>目前的可视化界面，没有logo，在今日数据概览中需要加一个显示当前时间的组件。这个Antd Pro的Pie组件真的很迷。</p><p>历史数据查询需要增加日期选择控件。对于历史数据，我准备存在MySQL中，这里就要思考每日定时dump的问题。</p><p>对于前端数据埋点的信息，先显示出来好了。</p><p>刷LeetCode去了。</p>]]></content>
      
      
      <categories>
          
          <category> 每周记录 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Minions-frontend 框架技术结构</title>
      <link href="/2019/03/21/minions-frontend-overview/"/>
      <url>/2019/03/21/minions-frontend-overview/</url>
      
        <content type="html"><![CDATA[<h2 id="前端技术选型"><a href="#前端技术选型" class="headerlink" title="前端技术选型"></a>前端技术选型</h2><ul><li>react 16.8.4</li><li>Ant Design (<a href="https://v1.pro.ant.design/docs/getting-started-cn" target="_blank" rel="noopener">Pro v1</a>) 3.15.0</li><li>XMLRequest:axios 0.18.0</li><li>路由: react-router-dom</li><li><a href="https://ant.design/docs/react/recommendation-cn" target="_blank" rel="noopener">精选组件</a></li></ul><h2 id="目录结构"><a href="#目录结构" class="headerlink" title="目录结构"></a>目录结构</h2><ul><li>components 放置个性化组件<ul><li>PageView 展示PV相关数据组件</li></ul></li><li>contents 主体部分抽象布局<ul><li>Overview 今日数据概览</li><li>HistoryView 历史数据查询</li></ul></li><li>pages 页面（目前为单页面）</li></ul><h2 id="React-Router"><a href="#React-Router" class="headerlink" title="React-Router"></a>React-Router</h2><ul><li>react-router-dom 是对 react-router 在浏览器开发环境下的封装，所以没有本质差别</li></ul><h2 id="ant-design-pro"><a href="#ant-design-pro" class="headerlink" title="ant design pro"></a>ant design pro</h2><ul><li>需要引入css文件<br><code>import &#39;ant-design-pro/dist/ant-design-pro.css&#39;;</code></li></ul><h2 id="BizChart"><a href="#BizChart" class="headerlink" title="BizChart"></a><a href="https://bizcharts.net/index" target="_blank" rel="noopener">BizChart</a></h2><ul><li>商业场景下的数据可视化</li></ul><h2 id="react相关"><a href="#react相关" class="headerlink" title="react相关"></a>react相关</h2><ul><li><a href="http://www.cnblogs.com/xianyulaodi/p/5038258.html" target="_blank" rel="noopener">dangerouslySetInnerHTML, 让React正常显示你的html代码</a></li><li><p><a href="https://github.com/pvoznyuk/react-live-clock" target="_blank" rel="noopener">时间显示组件</a></p><ul><li><p>获取今天的时间</p><p><code>const today = moment().format(&#39;YYYYMMDD&#39;);</code></p></li></ul></li><li><p>react setState是异步调用的</p><ul><li>使用props和componentWillReceiveProps(nextProps)来解决</li><li><a href="https://github.com/fangmiao97/MessageWiKiPro-frontend/blob/master/src/TopicInfo.js" target="_blank" rel="noopener">见topicid的变换</a></li><li>在minions中的历史数据页面，需要根据选择的不同日期显示相关数据。日期选择为父组件中的state.date改变，并将state.date传给child组件。child接收后通过componentWillReceiveProps来进行更新</li></ul></li><li><p><a href="http://www.ruanyifeng.com/blog/2015/07/flex-grammar.html" target="_blank" rel="noopener">flex布局</a></p></li><li><p>RestFul API</p></li><li><p>组件定时刷新</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">componentDidMount() &#123;</span><br><span class="line">        <span class="keyword">this</span>.timer = setInterval(</span><br><span class="line">            () =&gt; &#123;</span><br><span class="line">                <span class="comment">//更新组件state...</span></span><br><span class="line">            &#125;,</span><br><span class="line">            <span class="number">60000</span></span><br><span class="line">        );</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></li><li><p>组件动态渲染</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//父组件</span></span><br><span class="line"><span class="keyword">this</span>.state = &#123;</span><br><span class="line">            songsInfoList:[]</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        render() &#123;</span><br><span class="line">                <span class="keyword">let</span> songInfoList = <span class="keyword">this</span>.state.songsInfoList;</span><br><span class="line">                <span class="keyword">return</span> (</span><br><span class="line">                    &lt;div&gt;</span><br><span class="line">                        &#123;</span><br><span class="line">                            songInfoList.map(<span class="function">(<span class="params">item, index</span>) =&gt;</span> &#123;</span><br><span class="line">                                <span class="keyword">return</span> &lt;MockSongComponent key=&#123;index&#125; songInfo=&#123;item&#125;/&gt;</span><br><span class="line">                            &#125;)</span><br><span class="line">                        &#125;</span><br><span class="line">                    &lt;/div&gt;</span><br><span class="line">                );</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line"><span class="comment">//子组件</span></span><br><span class="line"><span class="keyword">this</span>.state = &#123;</span><br><span class="line">            songInfo: <span class="keyword">this</span>.props.songInfo</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">render() &#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">let</span> songInfo = <span class="keyword">this</span>.state.songInfo;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span>(</span><br><span class="line">            &lt;div&gt;</span><br><span class="line">              &#123;songInfo.name&#125;</span><br><span class="line">              &#123;songInfo.coverUrl&#125;</span><br><span class="line">              ......</span><br><span class="line">            &lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">        );</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br></pre></td></tr></table></figure></li></ul>]]></content>
      
      
      <categories>
          
          <category> 毕业设计 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>毕业设计参考文献记录🎓</title>
      <link href="/2019/03/19/graduationDesignReferences/"/>
      <url>/2019/03/19/graduationDesignReferences/</url>
      
        <content type="html"><![CDATA[<h2 id="实时流处理应用场景"><a href="#实时流处理应用场景" class="headerlink" title="实时流处理应用场景"></a>实时流处理应用场景</h2><ul><li><a href="http://new.gb.oversea.cnki.net/KXReader/Detail?dbcode=CJFD&amp;filename=DNZS201825112&amp;uid=WEEvREcwSlJHSldRa1Fhb09jT0pkRlg1TFVqTzAvOUVLVWZDZmNBOEF0az0=$9A4hF_YAuvQ5obgVAqNKPCYcEjKensW4IQMovwHtwkF4VYPoHbKxJw!!" target="_blank" rel="noopener">Spark Streaming在实时计算中的应用研究</a>:延时限制在秒级的应用场景,电商实时营销。</li><li><a href="http://new.gb.oversea.cnki.net/KCMS/detail/detail.aspx?dbcode=CMFD&amp;dbname=CMFD201901&amp;filename=1018894622.nh&amp;uid=WEEvREcwSlJHSldRa1Fhb09jT0pkRlg1TFVqTzAvOUVLVWZDZmNBOEF0az0=$9A4hF_YAuvQ5obgVAqNKPCYcEjKensW4IQMovwHtwkF4VYPoHbKxJw!!&amp;v=MDAwNDFyQ1VSTE9mWk9kbUZpRGhWNzdJVkYyNkZydXhHdGZPclpFYlBJUjhlWDFMdXhZUzdEaDFUM3FUcldNMUY=" target="_blank" rel="noopener">基于Spark Streaming的实时日志分析与信息管理系统的设计与实现</a>:分析DDoS攻击。系统日志的信息安全审计</li><li><a href="http://new.gb.oversea.cnki.net/KCMS/detail/detail.aspx?dbcode=CMFD&amp;dbname=CMFD201801&amp;filename=1017292559.nh&amp;v=MTU5MjBlWDFMdXhZUzdEaDFUM3FUcldNMUZyQ1VSTE9mWk9kbUZ5amtWTHZMVkYyNkdiR3hITlRKcHBFYlBJUjg=&amp;uid=WEEvREcwSlJHSldRa1FhdkJkVG1CcDNRL2o5cjJMcDdKU2FGb00xSGNGND0=$9A4hF_YAuvQ5obgVAqNKPCYcEjKensW4IQMovwHtwkF4VYPoHbKxJw!!" target="_blank" rel="noopener">基于海量网络日志数据的实时流处理系统的设计与实现</a>:可以参考这部分的绪论部分</li><li><a href="https://www.infoq.cn/article/2016/01/spark-streaming-what-is-it-and-w" target="_blank" rel="noopener">大公司的应用</a></li><li><a href="https://www.infoq.cn/article/suning-realtime-log-analysis-system-spark-streaming" target="_blank" rel="noopener">苏宁基于 Spark Streaming 的实时日志分析系统实践</a></li></ul><h2 id="日志信息隐藏关系"><a href="#日志信息隐藏关系" class="headerlink" title="日志信息隐藏关系"></a>日志信息隐藏关系</h2><ul><li><a href="http://new.gb.oversea.cnki.net/KXReader/Detail?dbcode=CJFD&amp;filename=WJSY201705010&amp;UID=WEEvREcwSlJHSldRa1FhdkJkVG1CcDc5Ym4weGJzK0hVZ1FjREZpT1JEcz0%3d%249A4hF_YAuvQ5obgVAqNKPCYcEjKensW4IQMovwHtwkF4VYPoHbKxJw!!&amp;autoLogin=0" target="_blank" rel="noopener">大数据下基于Spark的电商实时推荐系统的设计与实现</a></li></ul><h2 id="研究目的-出发点"><a href="#研究目的-出发点" class="headerlink" title="研究目的/出发点"></a>研究目的/出发点</h2><ul><li><a href="https://www.zhihu.com/question/20624296/answer/15731592" target="_blank" rel="noopener">互联网闭环</a></li></ul><h2 id="关于spark-streaming业务算法的创新"><a href="#关于spark-streaming业务算法的创新" class="headerlink" title="关于spark streaming业务算法的创新"></a>关于spark streaming业务算法的创新</h2><ul><li><a href="http://new.gb.oversea.cnki.net/KXReader/Detail?dbcode=CJFD&amp;filename=WJSY201705010&amp;UID=WEEvREcwSlJHSldRa1FhdkJkVG1CcDc5Ym4weGJzK0hVZ1FjREZpT1JEcz0%3d%249A4hF_YAuvQ5obgVAqNKPCYcEjKensW4IQMovwHtwkF4VYPoHbKxJw!!&amp;autoLogin=0" target="_blank" rel="noopener">对有状态计算操作的基数计算的精确计算方法和估算方法进行了比较分析</a></li></ul><h2 id="架构参考"><a href="#架构参考" class="headerlink" title="架构参考"></a>架构参考</h2><ul><li><a href="https://book.douban.com/reading/37743267/" target="_blank" rel="noopener">参考</a></li></ul><h2 id="Spark"><a href="#Spark" class="headerlink" title="Spark"></a>Spark</h2><ul><li><a href="http://dblab.xmu.edu.cn/blog/985-2/" target="_blank" rel="noopener">Spark入门：RDD的设计与运行原理</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> 毕业设计 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>关于axios的CORS问题的解决</title>
      <link href="/2019/03/18/axioscorsquestions/"/>
      <url>/2019/03/18/axioscorsquestions/</url>
      
        <content type="html"><![CDATA[<h2 id="Axios基础"><a href="#Axios基础" class="headerlink" title="Axios基础"></a>Axios基础</h2><ul><li>参考网站<ul><li><a href="https://www.jianshu.com/p/7a9fbcbb1114" target="_blank" rel="noopener">中文文档</a></li><li><a href="https://www.kancloud.cn/yunye/axios/234845" target="_blank" rel="noopener">使用说明</a></li></ul></li><li>上下文知识<ul><li><a href="http://es6.ruanyifeng.com/#docs/promise" target="_blank" rel="noopener">Promise in ES6</a></li><li><a href="http://www.ruanyifeng.com/blog/2016/04/same-origin-policy.html" target="_blank" rel="noopener">浏览器同源政策及其规避方法</a> 同源政策的目的，是为了保证用户信息的安全，防止恶意的网站窃取数据</li><li><a href="http://www.ruanyifeng.com/blog/2016/04/cors.html" target="_blank" rel="noopener">跨域资源共享 CORS 详解</a> 实现CORS通信的关键是服务器。只要服务器实现了CORS接口，就可以跨源通信</li></ul></li></ul><h2 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h2><p>Access to XMLHttpRequest at ‘<a href="http://localhost:8080/hello&#39;" target="_blank" rel="noopener">http://localhost:8080/hello&#39;</a> from origin ‘<a href="http://localhost:3000&#39;" target="_blank" rel="noopener">http://localhost:3000&#39;</a> has been blocked by CORS policy: No ‘Access-Control-Allow-Origin’ header is present on the requested resource.</p><h2 id="解决方法"><a href="#解决方法" class="headerlink" title="解决方法"></a>解决方法</h2><ul><li><a href="https://my.oschina.net/hccake/blog/886606" target="_blank" rel="noopener">Spring利用@CrossOrigin注解 实现 支持CORS跨域请求</a> 在controller类头部加入注释</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@CrossOrigin</span>(origins = <span class="string">"*"</span>, maxAge = <span class="number">3600</span>)</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 技术总结 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> axios </tag>
            
            <tag> CORS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java中常用API</title>
      <link href="/2019/03/18/JavaUtilsAPI/"/>
      <url>/2019/03/18/JavaUtilsAPI/</url>
      
        <content type="html"><![CDATA[<h2 id="转换类型"><a href="#转换类型" class="headerlink" title="转换类型"></a>转换类型</h2><ul><li>String转Char[]:</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Char[] a = string。toCharArray();</span><br></pre></td></tr></table></figure><ul><li>Char[]转String</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//只能用</span></span><br><span class="line"><span class="keyword">return</span> <span class="keyword">new</span> String(<span class="keyword">char</span>[])</span><br></pre></td></tr></table></figure><h2 id="String操作"><a href="#String操作" class="headerlink" title="String操作"></a>String操作</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//创建String</span></span><br><span class="line">StringBuilder res = <span class="keyword">new</span> StringBuilder();</span><br><span class="line"><span class="comment">//添加字符</span></span><br><span class="line">res.append(something);</span><br><span class="line"><span class="comment">//转换</span></span><br><span class="line">String(res) stringbuilder.toString()</span><br><span class="line"><span class="comment">//reverse</span></span><br><span class="line">res.reverse();</span><br><span class="line"><span class="comment">//去掉首位空格</span></span><br><span class="line">res.trim();</span><br><span class="line"><span class="comment">//取char</span></span><br><span class="line">string.charAt(<span class="keyword">int</span> i)</span><br><span class="line"><span class="comment">//大小写转变</span></span><br><span class="line">toLowerCase()</span><br><span class="line">toUpperCase()</span><br></pre></td></tr></table></figure><h2 id="数字操作"><a href="#数字操作" class="headerlink" title="数字操作"></a>数字操作</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//sqrt</span></span><br><span class="line">Math.sqrt(num);</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 技术总结 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Websites Safari</title>
      <link href="/2019/03/18/websitesafari/"/>
      <url>/2019/03/18/websitesafari/</url>
      
        <content type="html"><![CDATA[<h2 id="脚手架"><a href="#脚手架" class="headerlink" title="脚手架"></a>脚手架</h2><ul><li><a href="http://scaffold.ant.design/#/" target="_blank" rel="noopener">antd脚手架市场</a></li></ul><h2 id="图解IT"><a href="#图解IT" class="headerlink" title="图解IT"></a>图解IT</h2><ul><li><a href="https://arcentry.com/blog/scaling-webapps-for-newbs-and-non-techies/" target="_blank" rel="noopener">Scaling webapps for newbs &amp; non-techies 大型网络扩展</a></li><li><a href="https://visualgo.net/zh" target="_blank" rel="noopener">算法可视化</a></li></ul><h2 id="React-Framework"><a href="#React-Framework" class="headerlink" title="React Framework"></a>React Framework</h2><ul><li><a href="https://nextjs.org/" target="_blank" rel="noopener">Next.js</a></li></ul><h2 id="前端"><a href="#前端" class="headerlink" title="前端"></a>前端</h2><ul><li><a href="https://ponyfoo.com/articles/brief-history-of-modularity" target="_blank" rel="noopener">JS变化历史</a></li><li><a href="https://iconsvg.xyz/" target="_blank" rel="noopener">图标定制</a></li><li><a href="https://codepen.io/ivorjetski/pen/xMJoYO" target="_blank" rel="noopener">纯CSS图片</a></li></ul><h2 id="开发"><a href="#开发" class="headerlink" title="开发"></a>开发</h2><ul><li><a href="https://zhuanlan.zhihu.com/p/32459776" target="_blank" rel="noopener">领域驱动设计在互联网业务开发中的实践</a></li></ul><h2 id="工具"><a href="#工具" class="headerlink" title="工具"></a>工具</h2><ul><li><a href="https://dbdiagram.io/home" target="_blank" rel="noopener">画ER图的</a></li></ul>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>移动互联实验室-前端组-参考培训计划🖥（1期）</title>
      <link href="/2019/03/18/frontendstudy/"/>
      <url>/2019/03/18/frontendstudy/</url>
      
        <content type="html"><![CDATA[<h2 id="基础知识🚶"><a href="#基础知识🚶" class="headerlink" title="基础知识🚶"></a>基础知识🚶</h2><ul><li><a href="http://www.imooc.com/code/49" target="_blank" rel="noopener">HTML代码练习</a>(第4周-第6周）</li><li><a href="https://wangdoc.com/javascript/" target="_blank" rel="noopener">JavaScript语言入门教程</a></li><li><a href="http://www.imooc.com/learn/36" target="_blank" rel="noopener">Js视频</a></li></ul><h2 id="进阶🏃"><a href="#进阶🏃" class="headerlink" title="进阶🏃"></a>进阶🏃</h2><ul><li><a href="http://es6.ruanyifeng.com/" target="_blank" rel="noopener">ECMAScript 6 入门</a></li><li><a href="https://www.imooc.com/learn/955" target="_blank" rel="noopener">ES6快速入门</a></li><li><a href="http://www.ruanyifeng.com/blog/2015/03/react.html" target="_blank" rel="noopener">React入门教程</a></li><li>使用React的网站：<ul><li><a href="http://www.facebook.com/" target="_blank" rel="noopener">Facebook</a></li><li><a href="http://instagram.com/" target="_blank" rel="noopener">Instagram</a></li><li><a href="https://www.zhihu.com/" target="_blank" rel="noopener">知乎</a></li></ul></li></ul><h2 id="React🚕"><a href="#React🚕" class="headerlink" title="React🚕"></a>React🚕</h2><ul><li><a href="https://juejin.im/post/59dcd87451882578c2084515" target="_blank" rel="noopener">从React脚手架工具学习React项目的最佳实践</a></li><li><a href="https://juejin.im/entry/5b3f3c82e51d45190905d3a2" target="_blank" rel="noopener">组件库（了解）</a></li><li><a href="http://www.ruanyifeng.com/blog/2016/09/react-technology-stack.html" target="_blank" rel="noopener">React 技术栈系列教程</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> 技术总结 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> react ES6 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Flume使用interceptors向不同的Kafka Consumers发送基于Topic维度的信息</title>
      <link href="/2019/03/16/FluemToKafkaBaseOnDifferntTopic/"/>
      <url>/2019/03/16/FluemToKafkaBaseOnDifferntTopic/</url>
      
        <content type="html"><![CDATA[<h1 id="需求"><a href="#需求" class="headerlink" title="需求"></a>需求</h1><ul><li>后端接口通过log4j转发给flume的Event是直接发给avro source，之后要交给kafka sink供不同的应用处理。如果对于不同的topic都用一个agent处理感觉略尴尬（没有尝试），所以用一个avro source进行接收，用flume的interceptor进行按topic分流。</li></ul><h1 id="方案流程"><a href="#方案流程" class="headerlink" title="方案流程"></a>方案流程</h1><ul><li>前端<ul><li>向后端上传数据时，加入topic字段</li></ul></li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">axios.get(<span class="string">"url/logtest"</span>, &#123;</span><br><span class="line">            params:&#123;</span><br><span class="line">                K_topic: <span class="string">'specialTopic'</span>,</span><br><span class="line">                contents: <span class="string">'contents'</span></span><br><span class="line">            &#125;</span><br></pre></td></tr></table></figure><ul><li>后端<ul><li>在log4j的logger.info中加入topic字段</li></ul></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">logger.info(<span class="string">"topic:"</span> + k_topic + <span class="string">" "</span> + <span class="string">"contents:"</span>+ contents);</span><br></pre></td></tr></table></figure><ul><li>flume配置（部分）</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">#source interceptor</span><br><span class="line">agent1.sources.avro-source.interceptors=i1</span><br><span class="line">agent1.sources.avro-source.interceptors.i1.type=regex_extractor</span><br><span class="line">agent1.sources.avro-source.interceptors.i1.regex=topic:(.*?) contents:(.*?)</span><br><span class="line">agent1.sources.avro-source.interceptors.i1.serializers=s1 s2</span><br><span class="line">#agent1.sources.avro-source.interceptors.i1.serializers.s1.type=default</span><br><span class="line">agent1.sources.avro-source.interceptors.i1.serializers.s1.name=topic</span><br><span class="line">#agent1.sources.avro-source.interceptors.i1.serializers.s2.type=default</span><br><span class="line">agent1.sources.avro-source.interceptors.i1.serializers.s2.name=contents</span><br><span class="line"></span><br><span class="line">#define sink</span><br><span class="line">agent1.sinks.kafka-sink.type=org.apache.flume.sink.kafka.KafkaSink</span><br><span class="line">agent1.sinks.kafka-sink.topic = %&#123;topic&#125;</span><br></pre></td></tr></table></figure><ul><li>结果<br>不同的kafka Producer能够接收不同topic的埋点数据，之后的consumer也能消费到了</li></ul><h1 id="参考文档"><a href="#参考文档" class="headerlink" title="参考文档"></a>参考文档</h1><ul><li><a href="http://flume.apache.org/releases/content/1.9.0/FlumeUserGuide.html#regex-extractor-interceptor" target="_blank" rel="noopener">regex-extractor-interceptor正则表达式interceptor</a></li><li><a href="http://lxw1234.com/archives/2015/11/543.htm" target="_blank" rel="noopener">interceptor</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> 技术总结 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 开发相关 </tag>
            
            <tag> Flume </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>每周记录📝（190316）</title>
      <link href="/2019/03/16/weeklyReport190316/"/>
      <url>/2019/03/16/weeklyReport190316/</url>
      
        <content type="html"><![CDATA[<p><img src="https://wx1.sinaimg.cn/mw1024/6a49516fly1g14vxty5rbj21400u0e82.jpg" alt="学校的傍晚"></p><p>这一周将毕业设计的开头部分完成了链路打通，具体就是在前端埋点得到的数据能够在kafka中分topic消费。</p><p>其实这之间走了很多弯路，自己反复查资料才发现一个正确的方法。现在才意识到做项目需要一个指导老师的重要性，同样企业需要技术的布道师也是这个道理。</p><p>我的毕设是使用spark streaming进行网站流量的分析。其实对于毕设很尴尬的一点事，没有真实的业务数据，只能自己凭空制造。另外我觉得高校中的毕业设计，真的越来越水，就像是一个大一点的课程设计，自己独立完成的那种。</p><p>这一周我首先想完成通过自己在前端埋点，收集到数据，并能够给后面的业务流程使用。我的前端使用react，埋点的数据收集打算用flume收集。最开始的思路是使用flume的HTTPSource直接收集来自前端POST请求中的数据，可是通过查阅文档发现，无法完成。因为HTTPSource接受的需要是flume的Event对象，前端直接发来的数据不符合要求。所以说前端的任务只要完成原始数据收集的工作就可以了，其他必要的转换由后端完成。</p><p>还有一点就是，经别人提醒，如果说用flume直接收集网络上的数据还有安全的问题（见<a href="https://www.v2ex.com/t/543592#reply4" target="_blank" rel="noopener">V2ex帖子</a>）。所以有后端转发的必要。所以在这里我就有个疑惑，关于HTTPSource的使用场景到底是什么？</p><p>进过反复的尝试，确定了方案是：前端埋点采集到的数据由后端接受，并发送log4j日志给flume，再由flume的interceptor进行过滤（分流），分成不同的topic给kafka的消费者使用，之后就可以给spark streaming使用啦。(解决方案<a href="https://fangmiao97.github.io/2019/03/16/FluemToKafkaBaseOnDifferntTopic/" target="_blank" rel="noopener">见文章</a>)</p><p>不过现在遗留下的问题就是，前端使用axios出现跨域访问的问题。这个问题下周开始解决。下周要完成的任务就是把前端的框架搭好，开始学习spark streaming深入一点的东西，然后找需求。目前的需求太单薄了，不怎么丰富。</p><p>本周还做了点其他的事，总之效率没有那么高吧。这两天刷LeetCode也刷不起来，不知道为啥。所以这两天休息了一下，没刷。</p><p>感觉自己有的时候总被一些东西打扰，自己的控制力不够。另外看书的速度也挺慢的。看了名人传记，感觉厉害的人为何有那么多精力呢？</p><p>最近看到好玩的图，取名我的毕设，哈哈哈🤣<br><img src="https://wx2.sinaimg.cn/mw1024/6a49516fly1g14w7kwjt8j20j60n4dks.jpg" alt="我的毕设"></p>]]></content>
      
      
      <categories>
          
          <category> 每周记录 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>LeetCode刷题总结（持续更新）</title>
      <link href="/2019/03/15/MyLeetCodeSummarize/"/>
      <url>/2019/03/15/MyLeetCodeSummarize/</url>
      
        <content type="html"><![CDATA[<p>我的答案仓库地址：<a href="https://github.com/fangmiao97/MyLeetCode" target="_blank" rel="noopener">MyLeetCode</a></p><h2 id="Tree与迭代、动态规划"><a href="#Tree与迭代、动态规划" class="headerlink" title="Tree与迭代、动态规划"></a>Tree与迭代、动态规划</h2><ul><li><a href="https://leetcode.com/problems/maximum-binary-tree/" target="_blank" rel="noopener">Maximum Binary Tree</a><ul><li>思路：将创建最大二叉树，即根节点比所有叶子节点都大，的过程，分解成先寻找到当前数列中最大值，然后在创建左右最大子树的过程</li><li>退出情况是数列为一个数时返回null，即表示结束没有子树可以构造了</li></ul></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">TreeNode root = <span class="keyword">new</span> TreeNode(nums[max_i]);</span><br><span class="line">root.left = construct(nums, l, max_i);</span><br><span class="line">root.right = construct(nums, max_i + <span class="number">1</span>, r);</span><br></pre></td></tr></table></figure><ul><li><a href="https://leetcode.com/problems/maximum-binary-tree-ii/" target="_blank" rel="noopener">Maximum Binary Tree II</a><ul><li>描述：在一棵现成的最大二叉树中，插入一个数，使得插入之后依然是最大二叉树</li><li>技巧点：比根节点小的数一律往根节点的右子树插。</li><li>思路：插入值与当前根节点的值比较，若大于根节点的值则创建节点，并将原根节点作为自己的左子结点，并返回新的根节点。否则的话插入值插入原根节点的右子树，并循环这个过程。若插入值比较到最后，即与null比较，则创建该节点并返回这个节点。</li></ul></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> TreeNode <span class="title">insertIntoMaxTree</span><span class="params">(TreeNode root, <span class="keyword">int</span> val)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> TreeNode(val);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(root.val&lt;val)&#123;</span><br><span class="line">            TreeNode head = <span class="keyword">new</span> TreeNode(val);</span><br><span class="line">            head.left = root;</span><br><span class="line">            <span class="keyword">return</span> head;</span><br><span class="line">        &#125;</span><br><span class="line">        root.right = insertIntoMaxTree(root.right, val);</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><ul><li><a href="https://leetcode.com/problems/second-minimum-node-in-a-binary-tree/" target="_blank" rel="noopener">Second Minimum Node In a Binary Tree</a><ul><li>需要注意的事，必须将所有的节点都遍历完全才能找到第二小的数字。因为有一个用例将第二小的数值藏在了最下面</li><li>采用DFS或BFS都可以。关键是判断第二小的时候，先要将第一小的数找到，如果之后有数字不是小于<strong>等于</strong>第一小的话，才可以比较是不是第二小。如果只是单纯的小于第一小，会让第二小也成为和第一小一样的数值。</li></ul></li><li>BFS常用结构</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Queue&lt;TreeNode&gt; a = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">a.offer(p);</span><br><span class="line"><span class="keyword">while</span> (!a.isEmpty())&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> sz = a.size(); sz &gt; <span class="number">0</span>; --sz) &#123;</span><br><span class="line">        TreeNode n = a.poll();</span><br><span class="line">        <span class="comment">//do something</span></span><br><span class="line">        a.offer(n.left);</span><br><span class="line">        a.offer(n.right);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><ul><li><a href="https://leetcode.com/problems/sum-of-root-to-leaf-binary-numbers/" target="_blank" rel="noopener">Sum of Root To Leaf Binary Numbers</a><ul><li>DFS</li></ul></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">sumRootToLeaf</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> dfs(root, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">dfs</span><span class="params">(TreeNode root, <span class="keyword">int</span> sum)</span> </span>&#123;        </span><br><span class="line">    <span class="keyword">if</span>(root == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    sum = sum * <span class="number">2</span> + root.val;</span><br><span class="line">    <span class="keyword">return</span> root.left == root.right ? sum : dfs(root.left, sum) + dfs(root.right, sum);</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="字节-位处理"><a href="#字节-位处理" class="headerlink" title="字节/位处理"></a>字节/位处理</h2><ul><li><a href="https://leetcode.com/problems/reverse-integer/" target="_blank" rel="noopener">Reverse Integer</a><ul><li>java中不同数据类型的取值范围<ul><li>int 32</li><li>short 16</li><li>long 64</li><li>float 32</li><li>double 64</li></ul></li><li>本题中关于溢出可能的判断</li></ul></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//方式一</span></span><br><span class="line"><span class="comment">//正数溢出情况（2147483647）</span></span><br><span class="line"><span class="keyword">if</span> (rev &gt; Integer.MAX_VALUE/<span class="number">10</span> || (rev == Integer.MAX_VALUE / <span class="number">10</span> &amp;&amp; pop &gt; <span class="number">7</span>)) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"><span class="comment">//负数（-2147483648）</span></span><br><span class="line"><span class="keyword">if</span> (rev &lt; Integer.MIN_VALUE/<span class="number">10</span> || (rev == Integer.MIN_VALUE / <span class="number">10</span> &amp;&amp; pop &lt; -<span class="number">8</span>)) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//方式二</span></span><br><span class="line"><span class="keyword">if</span>((rev - pop) / <span class="number">10</span> != org) <span class="keyword">return</span> <span class="number">0</span>;<span class="comment">//溢出的话肯定计算不出原来的数字了</span></span><br></pre></td></tr></table></figure><ul><li><a href="https://leetcode.com/problems/number-of-1-bits/" target="_blank" rel="noopener">Number of 1 Bits</a><ul><li>找一个int数的二进制中有多少个1，hamming weight</li><li>&amp; – 位与运算 | – 位或运算</li></ul></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">31</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">            <span class="keyword">if</span>((n &amp; <span class="number">1</span>) == <span class="number">1</span>)</span><br><span class="line">                res++;</span><br><span class="line">            n &gt;&gt;= <span class="number">1</span>; <span class="comment">//右移一位</span></span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure><ul><li><p><a href="https://zhuanlan.zhihu.com/p/30108890" target="_blank" rel="noopener">java中的移位操作符</a></p></li><li><p><a href="https://leetcode.com/problems/reverse-bits/" target="_blank" rel="noopener">Reverse Bits</a></p><ul><li>翻转32位比特值，依次移动每一位。将每次需要移动的比特放在最后一位。与1进行位与操作后，将这一位移动到正确的位置后，与结果进行位或操作。</li></ul></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">31</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">            ans = ans | ((n &amp; <span class="number">1</span>) &lt;&lt; i);</span><br><span class="line">            n &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure><ul><li><p><a href="https://leetcode.com/problems/counting-bits/" target="_blank" rel="noopener">Counting Bits</a></p><ul><li><p><strong>DP</strong> When it comes to even numbers, i.e, 2,4,6,8, their binary should be like ‘10’, ‘100’, ‘110’, ‘1000’<br>so one notable difference is their unit digit is always 0,<br>which means when you call &gt;&gt; 1- shift one bit rightwards<br>and also means dividing by 2- would cause no change to the count of ‘1’ in the binary string.</p><p>Vice versa, when you meet odd numbers, shifting one bit rightwards always eliminates one ‘1’ digit from original binary string,<br>that is why we should “compensate” one ‘1’ character to the count.</p><p>To sum up, when you meet even number the count of ‘1’s is always the same as its half number,<br>on the other hand, remember to plus one to the odds’ half number.</p></li></ul></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span>[] f = <span class="keyword">new</span> <span class="keyword">int</span>[num + <span class="number">1</span>];</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">1</span>; i&lt;=num; i++) f[i] = f[i &gt;&gt; <span class="number">1</span>] + (i &amp; <span class="number">1</span>);</span><br><span class="line"><span class="keyword">return</span> f;</span><br></pre></td></tr></table></figure><h2 id="Two-Pointers"><a href="#Two-Pointers" class="headerlink" title="Two Pointers"></a>Two Pointers</h2><ul><li><p><a href="https://chocoluffy.com/2016/12/04/浅析经典面试算法题-two-pointer的运用/" target="_blank" rel="noopener">浅析经典面试算法题-two pointer的运用</a></p></li><li><p>Two Sum</p><ul><li>integer array已经过排序</li><li>两个pointers一头一尾。那么sum只有三种可能：<ul><li>sum == target，则返回</li><li>sum &lt; target，头指针向后走一个</li><li>sum &gt; target，尾指针向前走一个</li></ul></li><li>循环条件，头 &lt; 尾</li></ul></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> low = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> high = nums.length - <span class="number">1</span>;</span><br><span class="line"><span class="keyword">while</span>(low &lt; high) &#123;</span><br><span class="line">    <span class="keyword">if</span>(nums[low] + nums[high] == target)</span><br><span class="line">        <span class="comment">//do something;</span></span><br><span class="line">        <span class="comment">// low++ high--;</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (nums[low] + nums[high] &lt; target)</span><br><span class="line">        low++;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        high--;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>3Sum<ul><li>先将数列排序，再固定第一个数字，从剩下的数列中用2 sum的方法找。</li><li>注意一些要过滤的条件：<ul><li>第一个数字在移动的过程中，如果与前一个一样的话，就再移一下</li><li>low和high移动的道理也一样</li></ul></li></ul></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; threeSum(<span class="keyword">int</span>[] nums) &#123;</span><br><span class="line">       Arrays.sort(nums);</span><br><span class="line">       List&lt;List&lt;Integer&gt;&gt; res = <span class="keyword">new</span> ArrayList&lt;&gt;()</span><br><span class="line">       <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.length - <span class="number">2</span>; i++) &#123;</span><br><span class="line">           <span class="keyword">if</span>(i == <span class="number">0</span> || nums[i] != nums[i - <span class="number">1</span>]) &#123;</span><br><span class="line">               <span class="keyword">int</span> low = i + <span class="number">1</span>;</span><br><span class="line">               <span class="keyword">int</span> high = nums.length - <span class="number">1</span>;</span><br><span class="line">               <span class="keyword">int</span> remain = <span class="number">0</span> - nums[i];</span><br><span class="line">               <span class="keyword">while</span>(low &lt; high) &#123;</span><br><span class="line">                   <span class="keyword">if</span>(nums[low] + nums[high] == remain) &#123;</span><br><span class="line">                       res.add(Arrays.asList(nums[i], nums[low], nums[high]));</span><br><span class="line">                       <span class="keyword">while</span>(low &lt; high &amp;&amp; nums[low + <span class="number">1</span>] == nums[low])</span><br><span class="line">                           low++;</span><br><span class="line">                       <span class="keyword">while</span>(low &lt; high &amp;&amp; nums[high - <span class="number">1</span>] == nums[high])</span><br><span class="line">                           high--;</span><br><span class="line">                       low++;</span><br><span class="line">                       high--;</span><br><span class="line">                   &#125;<span class="keyword">else</span> <span class="keyword">if</span>(nums[low] + nums[high] &lt; remain)</span><br><span class="line">                       low++;</span><br><span class="line">                   <span class="keyword">else</span></span><br><span class="line">                       high--;</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">return</span> res;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><ul><li><p>3Sum closest</p><ul><li>找最接近的sum（也可能相等）</li><li>增加判断条件Math.abs小的话，就要更新。</li></ul></li><li><p>3Sum With Multiplicity</p><ul><li>每一中情况都要考虑到–排列组合</li></ul></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (A[j] == A[k]) &#123;</span><br><span class="line">  <span class="comment">// If A[j...k] are all equal, then there are C(k - j + 1, 2) </span></span><br><span class="line">  <span class="comment">// combinations that meet the requirement.取两个</span></span><br><span class="line">  res = (res + (k - j + <span class="number">1</span>) * (k - j) / <span class="number">2</span>) % m;</span><br><span class="line">  <span class="keyword">break</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">int</span> l = <span class="number">1</span>, r = <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">while</span> (j + l &lt; k &amp;&amp; A[j + l] == A[j]) &#123; ++l; &#125; <span class="comment">// l: number of elements equal to A[j].</span></span><br><span class="line">  <span class="keyword">while</span> (j &lt; k - r &amp;&amp; A[k - r] == A[k]) &#123; ++r; &#125; <span class="comment">// r: number of elements equal to A[k].</span></span><br><span class="line">  res = (res + l * r) % m; <span class="comment">// found l * r cases that meet the requirement.</span></span><br><span class="line">  j += l; <span class="comment">// forward j by l steps.</span></span><br><span class="line">  k -= r; <span class="comment">// backward k by r steps.</span></span><br></pre></td></tr></table></figure><ul><li>Sum of Square Numbers<ul><li>c = a^2 + b^2</li></ul></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">judgeSquareSum</span><span class="params">(<span class="keyword">int</span> c)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> limit = (<span class="keyword">int</span>)Math.sqrt(c);</span><br><span class="line">        <span class="keyword">int</span> low = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(low&lt;=limit)&#123;</span><br><span class="line">            <span class="keyword">int</span> sum = low*low + limit*limit;</span><br><span class="line">            <span class="keyword">if</span>(c==sum)&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(sum&lt;c)&#123;</span><br><span class="line">               low++;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">               limit--; </span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h2 id="基础字符串操作"><a href="#基础字符串操作" class="headerlink" title="基础字符串操作"></a>基础字符串操作</h2><ul><li><p>reverse</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">reverse</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">     StringBuilder res=<span class="keyword">new</span> StringBuilder();</span><br><span class="line">       <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; s.length(); i++)</span><br><span class="line">           res.insert(<span class="number">0</span>,s.charAt(i));</span><br><span class="line">       <span class="keyword">return</span> res.toString();</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure></li><li><p>split 对应API public String[] split(String regex, int limit)</p></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> String[] split(String s) &#123;</span><br><span class="line">        ArrayList &lt; String &gt; words = <span class="keyword">new</span> ArrayList &lt; &gt; ();</span><br><span class="line">        StringBuilder word = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; s.length(); i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (s.charAt(i) == <span class="string">' '</span>) &#123;</span><br><span class="line">                words.add(word.toString());</span><br><span class="line">                word = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">            &#125; <span class="keyword">else</span></span><br><span class="line">                word.append( s.charAt(i));</span><br><span class="line">        &#125;</span><br><span class="line">        words.add(word.toString());</span><br><span class="line">        <span class="keyword">return</span> words.toArray(<span class="keyword">new</span> String[words.size()]);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><ul><li>大小写转换<ul><li>a - 97 0x61(0110 0001) A - 65 0x41(0100 0001)</li></ul></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//法一</span></span><br><span class="line">string.toLowerCase() <span class="function">or <span class="title">toUpperCase</span><span class="params">()</span></span></span><br><span class="line"><span class="function"><span class="comment">//法二</span></span></span><br><span class="line"><span class="function"><span class="title">if</span> <span class="params">(<span class="string">'A'</span> &lt;= a[i] &amp;&amp; a[i] &lt;= <span class="string">'Z'</span>)</span></span></span><br><span class="line"><span class="function">    a[i] </span>= (<span class="keyword">char</span>) (a[i] - <span class="string">'A'</span> + <span class="string">'a'</span>);</span><br><span class="line"><span class="comment">//法三，按位或，把第五位的1加上</span></span><br><span class="line"><span class="keyword">char</span> c = (<span class="keyword">char</span>)(str.charAt(i) | (<span class="keyword">char</span>)(<span class="number">32</span>));</span><br></pre></td></tr></table></figure><ul><li>相同前缀<ul><li>indexOf（int，ch）：先看第一个indexOf它返回值是int，在看它的参数（int，ch）意思就是使用者可以给参数一个‘char’字符所代表的int值，然后去从前向后找到该字符在字符串中第一次出现处的索引，当然了我们不可能记得住每一个char的值所以我们在使用时直接用String s=abcdef;　int i=s.indexOf(‘d’)<br>这种方式就可以了，char类型会自动提升为int类型，还有就是要注意如果返回值为-1，就说明索引越界了；</li><li>indexOf（int ch，int，fromIndex）：这个方法就是说从指定位置往后找返回字符在该字符串中第一次出现处的索引，比如“woaizhongguo”indexOf（’o’,2）那返回值就是6而不是1，也不是11；</li><li>indexOf（Sting str）：这个方法基本就类似前面的了，只不过它是在参数里给一个子字符串，然后返回该子字符串在该字符串中第一次出现处的索引，比如”woaixuexi”要查”ai”这个子字符串在整个字符串中出现的索引位置那返回值就是2</li><li>indexOf（String str，int fromIndex）这个方法不在累述</li><li>lastIndexOf（int ch）：这个方法也是跟indexof相反，它是从后往前找返回字符在字符串中最后一次出现处的索引，也就是说找索引的时候是倒着找的但是返回值还是按照正的索引顺序返回的比如”woaiwo”用lastindexof查找‘w’返回的值是4而不是1</li><li>lastIndexOf(int ch,fromindex)</li></ul></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">longestCommonPrefix</span><span class="params">(String[] strs)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(strs.length == <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="string">""</span>;</span><br><span class="line">    String prefix = strs[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; strs.length; i++) &#123;</span><br><span class="line">        <span class="keyword">while</span>(strs[i].indexOf(prefix) != <span class="number">0</span>) &#123;<span class="comment">//前缀肯定是最短的，所以如果有这个相同前缀的话，肯定在每个string里面都有</span></span><br><span class="line">            prefix = prefix.substring(<span class="number">0</span>, prefix.length() - <span class="number">1</span>);<span class="comment">//前缀就从第一个字符串进行截取就可以了</span></span><br><span class="line">            <span class="keyword">if</span>(prefix.isEmpty())</span><br><span class="line">                <span class="keyword">return</span> <span class="string">""</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> prefix;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="非常规顺序操作"><a href="#非常规顺序操作" class="headerlink" title="非常规顺序操作"></a>非常规顺序操作</h2><ul><li><a href="https://leetcode.com/problems/zigzag-conversion/" target="_blank" rel="noopener">ZigZag Conversion</a><ul><li>取相同数字位的进行操作：0123210123210..</li><li>法一：能够发现0之后都是加一，3之后都是减一</li><li>设置一个标志来判断是否加一还是减一</li><li>法二：变步长</li></ul></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//1</span></span><br><span class="line"><span class="keyword">if</span>(curRow == <span class="number">0</span> || curRow == numRows - <span class="number">1</span>) goingDown = !goingDown;</span><br><span class="line">curRow += goingDown ? <span class="number">1</span> : -<span class="number">1</span>;</span><br><span class="line"><span class="comment">//2</span></span><br><span class="line">        <span class="keyword">int</span> n = s.length();</span><br><span class="line">        <span class="keyword">int</span> cycleLen = <span class="number">2</span> * numRows - <span class="number">2</span>; <span class="comment">//numRows = 4</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; numRows; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j + i &lt; n; j += cycleLen) &#123;</span><br><span class="line">                ret.append(s.charAt(j + i));</span><br><span class="line">                <span class="keyword">if</span> (i != <span class="number">0</span> &amp;&amp; i != numRows - <span class="number">1</span> &amp;&amp; j + cycleLen - i &lt; n)</span><br><span class="line">                    ret.append(s.charAt(j + cycleLen - i));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure><h2 id="数字计算"><a href="#数字计算" class="headerlink" title="数字计算"></a>数字计算</h2><ul><li>pow(x, n)<ul><li>n%2==0 -&gt; x^n = x^(n/2) <em> x^(n/2) = (x</em>x)^(n/2)</li><li>n%2==1 -&gt; x^n = x<em>(x^(n/2) </em> x^(n/2)) = x <em> (x</em>x)^(n/2)</li></ul></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">pow</span><span class="params">(<span class="keyword">double</span> x, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">if</span>(n == <span class="number">0</span>)</span><br><span class="line">                <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span>(n == Integer.MIN_VALUE)&#123;<span class="comment">//-2147483648不能直接换成正的，会溢出</span></span><br><span class="line">                <span class="keyword">return</span> myPow(x*x, n/<span class="number">2</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(n &lt; <span class="number">0</span>)&#123;</span><br><span class="line">                x = <span class="number">1</span>/x;</span><br><span class="line">                n = -n;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(n%<span class="number">2</span> == <span class="number">1</span>) </span><br><span class="line">                <span class="keyword">return</span> myPow(x*x, n/<span class="number">2</span>)*x;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                <span class="keyword">return</span> myPow(x*x, n/<span class="number">2</span>);</span><br><span class="line">                &#125;</span><br></pre></td></tr></table></figure><ul><li><p>sqrt(x)</p><ul><li><p>I have seen many variants using Binary Search, the key difference is the search range. It seems easy to do it but actually there are some traps we need to take care. I made this just for a note for me.<br>Search range summary:</p><ul><li><a href="easy but not recommend">1, Integer.MAX_VALUE</a></li><li><a href="recommended">1, x</a></li><li><a href="you need to do math to prove it">1, x/2</a></li></ul></li><li>For case 2 and case 3, we need to take care of the corner case by making sure right &gt;= left for [left, right], so:<ol start="2"><li>x &gt;= 1 for [1, x] =&gt; so we need to take care of the corner case: x &lt; 1</li><li>x/2 &gt;= 1 for [1, x/2]=&gt; x &gt;= 2 =&gt; so we need to take care of the corner case: x &lt; 2</li></ol></li></ul></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">mySqrt</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">long</span> l=<span class="number">0</span>,r=x; <span class="comment">//in case of overflow</span></span><br><span class="line">        <span class="keyword">while</span>(l&lt;r)&#123;</span><br><span class="line">            <span class="keyword">long</span> mid=l+(r-l)/<span class="number">2</span>+<span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span>(mid*mid&gt;x) r=mid-<span class="number">1</span>;</span><br><span class="line">            <span class="keyword">else</span> l=mid;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> (<span class="keyword">int</span>)l;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>计算加减式<ul><li><a href="https://leetcode.com/problems/basic-calculator/" target="_blank" rel="noopener">basic-calculator</a></li></ul></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">calculate</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">        Stack&lt;Integer&gt; stack = <span class="keyword">new</span> Stack&lt;Integer&gt;();</span><br><span class="line">        <span class="keyword">int</span> result = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> number = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> sign = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; s.length(); i++) &#123;</span><br><span class="line">            <span class="keyword">char</span> c = s.charAt(i);</span><br><span class="line">            <span class="keyword">if</span>(Character.isDigit(c)) &#123;</span><br><span class="line">                number = <span class="number">10</span> * number + (<span class="keyword">int</span>)(c  - <span class="string">'0'</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(c == <span class="string">'+'</span>) &#123;</span><br><span class="line">                number = sign * number;</span><br><span class="line">                result += number;</span><br><span class="line">                number = <span class="number">0</span>;</span><br><span class="line">                sign = <span class="number">1</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span>(c == <span class="string">'-'</span>) &#123;</span><br><span class="line">                number = sign * number;</span><br><span class="line">                result += number;</span><br><span class="line">                number = <span class="number">0</span>;</span><br><span class="line">                sign = -<span class="number">1</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span>( c == <span class="string">'('</span>) &#123;</span><br><span class="line">                stack.push(result);</span><br><span class="line">                stack.push(sign);</span><br><span class="line">                result = <span class="number">0</span>;</span><br><span class="line">                sign = <span class="number">1</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span>( c == <span class="string">')'</span>) &#123;</span><br><span class="line">                number = sign * number;</span><br><span class="line">                result += number;</span><br><span class="line">                number = <span class="number">0</span>; </span><br><span class="line">                result *= stack.pop();</span><br><span class="line">                result += stack.pop();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//最后以数字结尾的话</span></span><br><span class="line">        <span class="keyword">if</span>(number != <span class="number">0</span>) <span class="keyword">return</span> result += sign * number;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><ul><li>加减乘除</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">calculate</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">        Stack&lt;Integer&gt; stack = <span class="keyword">new</span> Stack&lt;Integer&gt;();</span><br><span class="line">        <span class="keyword">int</span> result = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> number = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">char</span> sign = <span class="string">'+'</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; s.length(); i++ ) &#123;</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">char</span> c = s.charAt(i);</span><br><span class="line">            <span class="keyword">if</span>(Character.isDigit(c)) &#123;</span><br><span class="line">                number = number * <span class="number">10</span> + (<span class="keyword">int</span>)(c - <span class="string">'0'</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>((!Character.isDigit(c) &amp;&amp; c != <span class="string">' '</span>) || i == s.length()-<span class="number">1</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span>( sign == <span class="string">'+'</span>) &#123;</span><br><span class="line">                    stack.push(number);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span>(sign == <span class="string">'-'</span>) &#123;</span><br><span class="line">                    stack.push(-number);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span>(sign == <span class="string">'*'</span>) &#123;</span><br><span class="line">                    stack.push(stack.pop() * number);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span>(sign == <span class="string">'/'</span>) &#123;</span><br><span class="line">                    stack.push(stack.pop() / number);</span><br><span class="line">                &#125;</span><br><span class="line">                </span><br><span class="line">                sign = c;</span><br><span class="line">                number = <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i : stack) &#123;</span><br><span class="line">            result += i;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><ul><li><a href="https://leetcode.com/problems/missing-number/" target="_blank" rel="noopener">Missing Num</a><ul><li>在n长的数组中，包含0到n这n+1个数字中的n个。有个一数字[0, n]不在里面。</li><li>将数组的索引[0, n-1]想成抽屉的编号，如果是n缺少的话，每个抽屉其实都能装到自己的数字，n就单独出来了。</li><li>如果是[0, n-1]中的数字缺少了，说明n这个数字占了其中一个抽屉，那个数字（索引编号还贴在抽屉上）就单出来了。</li><li>使用异或操作可以将单独的数字找出来。</li></ul></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">missingNumber</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;   </span><br><span class="line">       </span><br><span class="line">       <span class="keyword">int</span> missing = nums.length;</span><br><span class="line">       <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">           missing ^= i ^ nums[i];</span><br><span class="line">       &#125;</span><br><span class="line">       </span><br><span class="line">       <span class="keyword">return</span> missing;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><h2 id="Int处理"><a href="#Int处理" class="headerlink" title="Int处理"></a>Int处理</h2><ul><li>Palindrome Number 回文数<ul><li>转换成String 使用reverse()判断是否相同</li><li><a href="https://leetcode.com/problems/reverse-integer/" target="_blank" rel="noopener">reverse Integer</a>，再看是否相同，但是可能会溢出</li><li>只转换后一半的数字，与前面一半的数字比较：1221 –&gt; 12 12 12321 –&gt; 12 123/10</li></ul></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isPalindrome</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(x &lt; <span class="number">0</span> || (x % <span class="number">10</span> == <span class="number">0</span> &amp;&amp; x != <span class="number">0</span>))</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">int</span> rev = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(x &gt; rev) &#123; <span class="comment">//当前面的数字小于等于后面翻转的数字时，就到中间了</span></span><br><span class="line">        rev = rev * <span class="number">10</span> + x % <span class="number">10</span>;</span><br><span class="line">        x /= <span class="number">10</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> (x == rev || x == rev / <span class="number">10</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="LinkedList"><a href="#LinkedList" class="headerlink" title="LinkedList"></a>LinkedList</h2><ul><li>Remove Linked List Elements</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> ListNode <span class="title">removeElements</span><span class="params">(ListNode head, <span class="keyword">int</span> val)</span> </span>&#123;</span><br><span class="line">        ListNode dummy = <span class="keyword">new</span> ListNode(<span class="number">0</span>);</span><br><span class="line">        dummy.next = head;</span><br><span class="line">        head = dummy;</span><br><span class="line">        <span class="keyword">while</span>(head.next != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span>(head.next.val == val)</span><br><span class="line">                head.next = head.next.next;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                head = head.next;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><ul><li>middle ListNode</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> ListNode <span class="title">middleNode</span><span class="params">(ListNode head)</span> </span>&#123;</span><br><span class="line">    ListNode slow = head, fast = head;</span><br><span class="line">    <span class="keyword">while</span>(fast != <span class="keyword">null</span> &amp;&amp; fast.next != <span class="keyword">null</span>) &#123;</span><br><span class="line">        slow = slow.next;</span><br><span class="line">        fast = fast.next.next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> slow;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>reverse List<ul><li>将链表翻转</li></ul></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> ListNode <span class="title">reverse</span><span class="params">(ListNode head)</span> </span>&#123;</span><br><span class="line">    ListNode pre = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">while</span>(head != <span class="keyword">null</span>) &#123;</span><br><span class="line">        ListNode next = head.next;</span><br><span class="line">        head.next = pre;</span><br><span class="line">        pre = head;</span><br><span class="line">        head = next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> pre;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>翻转部分List<ul><li><a href="https://leetcode.com/problems/reverse-linked-list-ii/" target="_blank" rel="noopener">reverse list II</a></li></ul></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> ListNode <span class="title">reverseBetween</span><span class="params">(ListNode head, <span class="keyword">int</span> m, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span>(head == <span class="keyword">null</span> || n == <span class="number">1</span>) <span class="keyword">return</span> head;</span><br><span class="line">        </span><br><span class="line">        ListNode dummy = <span class="keyword">new</span> ListNode(<span class="number">0</span>);</span><br><span class="line">        dummy.next = head;</span><br><span class="line">        ListNode p = dummy;</span><br><span class="line">        <span class="keyword">while</span>(m &gt; <span class="number">1</span>) &#123;</span><br><span class="line">            p = p.next;</span><br><span class="line">            m--;</span><br><span class="line">            n--;</span><br><span class="line">        &#125;</span><br><span class="line">        ListNode tail = p.next;</span><br><span class="line">        </span><br><span class="line">        ListNode tmp = p;</span><br><span class="line">        <span class="keyword">while</span>(n &gt; <span class="number">1</span>) &#123;</span><br><span class="line">            tmp = p.next;</span><br><span class="line">            p.next = tail.next;</span><br><span class="line">            tail.next = tail.next.next;</span><br><span class="line">            p.next.next = tmp;</span><br><span class="line">            n--;</span><br><span class="line">        &#125;</span><br><span class="line">         </span><br><span class="line">        <span class="keyword">return</span> dummy.next;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><ul><li>有环的LinkedList<ul><li><a href="https://leetcode.com/problems/linked-list-cycle-ii/" target="_blank" rel="noopener">Linked List CycleII</a></li><li>two pointers看解释</li><li>延伸<a href="https://leetcode.com/problems/find-the-duplicate-number/" target="_blank" rel="noopener">287. Find the Duplicate Number</a></li><li>将数组当成链表的索引表</li><li>鸽笼原理，一个数组[n+1]中有1-n个不相同的数，肯定有一个数字是重复的。如果把数组中的每个数当做是索引值的话，没有重复数字的情况下，就会形成一个没有环的链。如果中间有重复值的话，就一定会出现环。</li></ul></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">findDuplicate</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> slow = nums[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">int</span> fast = nums[<span class="number">0</span>];</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">do</span>&#123;</span><br><span class="line">            slow = nums[slow];</span><br><span class="line">            fast = nums[nums[fast]];</span><br><span class="line">        &#125;<span class="keyword">while</span>(slow != fast);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">int</span> head = nums[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">while</span>(head != slow) &#123;</span><br><span class="line">            head = nums[head];</span><br><span class="line">            slow = nums[slow];</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> head;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><ul><li><a href="https://leetcode.com/problems/add-binary/" target="_blank" rel="noopener">二进制加</a><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">addBinary</span><span class="params">(String a, String b)</span> </span>&#123;</span><br><span class="line">        StringBuilder sb = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">        <span class="keyword">int</span> i = a.length(), j = b.lengthg(), carry = <span class="number">0</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span>(i &gt;= <span class="number">0</span> || j &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">int</span> sum = carry;</span><br><span class="line">            <span class="keyword">if</span>(j &gt;= <span class="number">0</span>) sum += b.charAt(j--) - <span class="string">'0'</span>;</span><br><span class="line">            <span class="keyword">if</span>(i &gt;= <span class="number">0</span>) sum += a.charAt(i--) - <span class="string">'0'</span>；</span><br><span class="line">            sb.insert(<span class="number">0</span>, sum % <span class="number">2</span>);</span><br><span class="line">            carry = sum / <span class="number">2</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span>(carry ！= <span class="number">0</span>)</span><br><span class="line">            sb.insert(<span class="number">0</span>, carry);</span><br><span class="line">        <span class="keyword">return</span> sb.toString();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></li></ul><h2 id="指针"><a href="#指针" class="headerlink" title="指针"></a>指针</h2><ul><li>将数组中的数当成指针<ul><li><a href="https://leetcode.com/problems/find-all-duplicates-in-an-array" target="_blank" rel="noopener">442. Find All Duplicates in an Array</a></li></ul></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> List&lt;Integer&gt; <span class="title">findDuplicates</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        List&lt;Integer&gt; res = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.length; ++i) &#123;</span><br><span class="line">            <span class="keyword">int</span> index = Math.abs(nums[i])-<span class="number">1</span>;<span class="comment">//要去绝对值 索引</span></span><br><span class="line">            <span class="keyword">if</span> (nums[index] &lt; <span class="number">0</span>)<span class="comment">//是负的说明，之前遇到过</span></span><br><span class="line">                res.add(Math.abs(index+<span class="number">1</span>));</span><br><span class="line">            nums[index] = -nums[index];</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><ul><li><ol start="448"><li>Find All Numbers Disappeared in an Array</li></ol></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> List&lt;Integer&gt; <span class="title">findDisappearedNumbers</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    List&lt;Integer&gt; res = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">        <span class="keyword">int</span> val = Math.abs(nums[i]) - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span>(nums[val] &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            nums[val] = - nums[val];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span>(nums[i] &gt; <span class="number">0</span> ) &#123;</span><br><span class="line">            res.add(i+<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="表达式校验"><a href="#表达式校验" class="headerlink" title="表达式校验"></a>表达式校验</h2><ul><li><a href="https://leetcode.com/problems/valid-parentheses/" target="_blank" rel="noopener">Valid Parentheses</a><ul><li>常规做法：用stack保存左括号，遇到右括号检验栈顶是不是对应的左括号，是的话就pop，不是就不正确</li><li>非常规，思想相同：</li></ul></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isValid</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">        Stack&lt;Character&gt; stack = <span class="keyword">new</span> Stack&lt;Character&gt;();</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">char</span> c : s.toCharArray()) &#123;</span><br><span class="line"><span class="keyword">if</span> (c == <span class="string">'('</span>)</span><br><span class="line">stack.push(<span class="string">')'</span>);</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (c == <span class="string">'&#123;'</span>)</span><br><span class="line">stack.push(<span class="string">'&#125;'</span>);</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (c == <span class="string">'['</span>)</span><br><span class="line">stack.push(<span class="string">']'</span>);</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (stack.isEmpty() || stack.pop() != c)</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> stack.isEmpty();</span><br></pre></td></tr></table></figure><h2 id="三分查找"><a href="#三分查找" class="headerlink" title="三分查找"></a>三分查找</h2><ul><li><a href="https://leetcode.com/problems/guess-number-higher-or-lower/solution/" target="_blank" rel="noopener">guess number</a></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">guessNumber</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> low = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> high = n;</span><br><span class="line">        <span class="keyword">while</span> (low &lt;= high) &#123;</span><br><span class="line">            <span class="keyword">int</span> mid1 = low + (high - low) / <span class="number">3</span>;</span><br><span class="line">            <span class="keyword">int</span> mid2 = high - (high - low) / <span class="number">3</span>;</span><br><span class="line">            <span class="keyword">int</span> res1 = guess(mid1);</span><br><span class="line">            <span class="keyword">int</span> res2 = guess(mid2);</span><br><span class="line">            <span class="keyword">if</span> (res1 == <span class="number">0</span>)</span><br><span class="line">                <span class="keyword">return</span> mid1;</span><br><span class="line">            <span class="keyword">if</span> (res2 == <span class="number">0</span>)</span><br><span class="line">                <span class="keyword">return</span> mid2;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (res1 &lt; <span class="number">0</span>)</span><br><span class="line">                high = mid1 - <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (res2 &gt; <span class="number">0</span>)</span><br><span class="line">                low = mid2 + <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                low = mid1 + <span class="number">1</span>;</span><br><span class="line">                high = mid2 - <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 技术总结 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>微信小程序开发🚀</title>
      <link href="/2019/03/14/%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8F%E5%AD%A6%E4%B9%A0%E6%84%8F%E8%A7%81/"/>
      <url>/2019/03/14/%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8F%E5%AD%A6%E4%B9%A0%E6%84%8F%E8%A7%81/</url>
      
        <content type="html"><![CDATA[<h2 id="布局样式📱"><a href="#布局样式📱" class="headerlink" title="布局样式📱"></a>布局样式📱</h2><ul><li><a href="https://www.imooc.com/learn/974" target="_blank" rel="noopener">入门教程视频</a></li><li><a href="http://www.imooc.com/code/49" target="_blank" rel="noopener">基础代码教程</a></li><li>相关实用网站<ul><li><a href="http://www.runoob.com/css/css-tutorial.html" target="_blank" rel="noopener">菜鸟教程</a></li><li><a href="https://developers.weixin.qq.com/miniprogram/dev/quickstart/basic/file.html#wxml-%E6%A8%A1%E6%9D%BF" target="_blank" rel="noopener">WXML与WXSS</a></li><li><a href="https://developers.weixin.qq.com/miniprogram/dev/framework/view/wxss.html" target="_blank" rel="noopener">WXSS主要注意尺寸单位</a></li><li><a href="https://developers.weixin.qq.com/miniprogram/dev/component/" target="_blank" rel="noopener">小程序的基本组件</a></li></ul></li></ul><h2 id="逻辑🗯"><a href="#逻辑🗯" class="headerlink" title="逻辑🗯"></a>逻辑🗯</h2><ul><li><a href="https://developers.weixin.qq.com/community/develop/article/doc/000aa057ca0a88dcd938b4d6656813" target="_blank" rel="noopener">PWA</a>(了解）</li><li><a href="https://www.v2ex.com/t/427255" target="_blank" rel="noopener">关于HTML5/小程序的产生</a>(了解）</li><li><a href="https://developers.weixin.qq.com/miniprogram/dev/quickstart/basic/file.html#js-%E4%BA%A4%E4%BA%92%E9%80%BB%E8%BE%91" target="_blank" rel="noopener">JS逻辑交互</a></li><li>相关实用网站<ul><li><a href="https://developers.weixin.qq.com/miniprogram/dev/quickstart/basic/framework.html#api" target="_blank" rel="noopener">小程序的API</a></li><li><a href="http://www.runoob.com/js/js-tutorial.html" target="_blank" rel="noopener">JavaScript</a></li><li><a href="http://www.runoob.com/json/json-tutorial.html" target="_blank" rel="noopener">JSON教程</a></li></ul></li></ul><h2 id="其他实用网站🕸"><a href="#其他实用网站🕸" class="headerlink" title="其他实用网站🕸"></a>其他实用网站🕸</h2><ul><li><a href="https://developers.weixin.qq.com/" target="_blank" rel="noopener">官方社区</a>:有的坑可能别人已经踩过，可以搜索一下</li><li><a href="https://minapp.com/miniapp/" target="_blank" rel="noopener">知晓程序</a>：可以看看别人产品的想法和思路</li><li><a href="https://tencent.github.io/wepy/" target="_blank" rel="noopener">WePY</a>：开发小程序的一个框架。建议看看就好，还是以原生开发为主。等原生上手后再看看框架。</li><li><a href="https://github.com/Shincey/HFUTSZK" target="_blank" rel="noopener">工大思政课</a>:无网络交互，可以独立开发完成。</li><li><a href="https://github.com/fangmiao97/AISmallTribe-weixinMiniProgram" target="_blank" rel="noopener">AI小部落</a>：js逻辑中有网络交互，可以做参考。</li><li>各种css样式配置web工具<ul><li><a href="https://www.html.cn/tool/css3Preview/Box-Shadow.html" target="_blank" rel="noopener">box、卡片的阴影效果</a></li><li>……</li></ul></li></ul><h2 id="建议🍻"><a href="#建议🍻" class="headerlink" title="建议🍻"></a>建议🍻</h2><ul><li>先学习基础<strong>HTML/CSS/JavaScript</strong>，不用特别抓细节，但是要知晓常见用法</li><li>理清三个方面：<ul><li>如何布局、添加样式</li><li>逻辑层与 ui 层如何交互，或者说如何用代码操控 ui 组件</li><li>如何处理用户的交互动作</li></ul></li><li>先从简单的功能开始开发，如，点击按钮显示图片文本。再逐渐复杂逻辑</li><li>小程序推荐用原生开发，先不要用框架</li><li>看官方文档，也要结合搜索引擎。因为微信的官方文档，有坑</li><li>每天新增一行代码都是进步😃加油！</li><li>逐渐理解<a href="https://developers.weixin.qq.com/miniprogram/dev/framework/app-service/page.html#%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F" target="_blank" rel="noopener">生命周期</a></li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> 开发相关 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
