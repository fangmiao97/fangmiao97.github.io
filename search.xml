<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>Flume使用interceptors向不同的Kafka Consumers发送基于Topic维度的信息</title>
      <link href="/2019/03/16/FluemToKafkaBaseOnDifferntTopic/"/>
      <url>/2019/03/16/FluemToKafkaBaseOnDifferntTopic/</url>
      
        <content type="html"><![CDATA[<h1 id="需求"><a href="#需求" class="headerlink" title="需求"></a>需求</h1><ul><li>后端接口通过log4j转发给flume的Event是直接发给avro source，之后要交给kafka sink供不同的应用处理。如果对于不同的topic都用一个agent处理感觉略尴尬（没有尝试），所以用一个avro source进行接收，用flume的interceptor进行按topic分流。</li></ul><h1 id="方案流程"><a href="#方案流程" class="headerlink" title="方案流程"></a>方案流程</h1><ul><li>前端<ul><li>向后端上传数据时，加入topic字段</li></ul></li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">axios.get(<span class="string">"url/logtest"</span>, &#123;</span><br><span class="line">            params:&#123;</span><br><span class="line">                K_topic: <span class="string">'specialTopic'</span>,</span><br><span class="line">                contents: <span class="string">'contents'</span></span><br><span class="line">            &#125;</span><br></pre></td></tr></table></figure><ul><li>后端<ul><li>在log4j的logger.info中加入topic字段</li></ul></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">logger.info(<span class="string">"topic:"</span> + k_topic + <span class="string">" "</span> + <span class="string">"contents:"</span>+ contents);</span><br></pre></td></tr></table></figure><ul><li>flume配置（部分）</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">#source interceptor</span><br><span class="line">agent1.sources.avro-source.interceptors=i1</span><br><span class="line">agent1.sources.avro-source.interceptors.i1.type=regex_extractor</span><br><span class="line">agent1.sources.avro-source.interceptors.i1.regex=topic:(.*?) contents:(.*?)</span><br><span class="line">agent1.sources.avro-source.interceptors.i1.serializers=s1 s2</span><br><span class="line">#agent1.sources.avro-source.interceptors.i1.serializers.s1.type=default</span><br><span class="line">agent1.sources.avro-source.interceptors.i1.serializers.s1.name=topic</span><br><span class="line">#agent1.sources.avro-source.interceptors.i1.serializers.s2.type=default</span><br><span class="line">agent1.sources.avro-source.interceptors.i1.serializers.s2.name=contents</span><br><span class="line"></span><br><span class="line">#define sink</span><br><span class="line">agent1.sinks.kafka-sink.type=org.apache.flume.sink.kafka.KafkaSink</span><br><span class="line">agent1.sinks.kafka-sink.topic = %&#123;topic&#125;</span><br></pre></td></tr></table></figure><ul><li>结果<br>不同的kafka consumer能够接收不同topic的埋点数据</li></ul><h1 id="参考文档"><a href="#参考文档" class="headerlink" title="参考文档"></a>参考文档</h1><ul><li><a href="http://flume.apache.org/releases/content/1.9.0/FlumeUserGuide.html#regex-extractor-interceptor" target="_blank" rel="noopener">regex-extractor-interceptor正则表达式interceptor</a></li><li><a href="http://lxw1234.com/archives/2015/11/543.htm" target="_blank" rel="noopener">interceptor</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> 技术总结 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 开发相关 </tag>
            
            <tag> Flume </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LeetCode刷题总结（持续更新）</title>
      <link href="/2019/03/16/MyLeetCodeSummarize/"/>
      <url>/2019/03/16/MyLeetCodeSummarize/</url>
      
        <content type="html"><![CDATA[<p>我的答案仓库地址：<a href="https://github.com/fangmiao97/MyLeetCode" target="_blank" rel="noopener">MyLeetCode</a></p><h2 id="Tree与迭代、动态规划"><a href="#Tree与迭代、动态规划" class="headerlink" title="Tree与迭代、动态规划"></a>Tree与迭代、动态规划</h2><ul><li><a href="https://leetcode.com/problems/maximum-binary-tree/" target="_blank" rel="noopener">Maximum Binary Tree</a><ul><li>思路：将创建最大二叉树，即根节点比所有叶子节点都大，的过程，分解成先寻找到当前数列中最大值，然后在创建左右最大子树的过程</li><li>退出情况是数列为一个数时返回null，即表示结束没有子树可以构造了</li></ul></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">TreeNode root = <span class="keyword">new</span> TreeNode(nums[max_i]);</span><br><span class="line">root.left = construct(nums, l, max_i);</span><br><span class="line">root.right = construct(nums, max_i + <span class="number">1</span>, r);</span><br></pre></td></tr></table></figure><ul><li><a href="https://leetcode.com/problems/maximum-binary-tree-ii/" target="_blank" rel="noopener">Maximum Binary Tree II</a><ul><li>描述：在一棵现成的最大二叉树中，插入一个数，使得插入之后依然是最大二叉树</li><li>技巧点：比根节点小的数一律往根节点的右子树插。</li><li>思路：插入值与当前根节点的值比较，若大于根节点的值则创建节点，并将原根节点作为自己的左子结点，并返回新的根节点。否则的话插入值插入原根节点的右子树，并循环这个过程。若插入值比较到最后，即与null比较，则创建该节点并返回这个节点。</li></ul></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> TreeNode <span class="title">insertIntoMaxTree</span><span class="params">(TreeNode root, <span class="keyword">int</span> val)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> TreeNode(val);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(root.val&lt;val)&#123;</span><br><span class="line">            TreeNode head = <span class="keyword">new</span> TreeNode(val);</span><br><span class="line">            head.left = root;</span><br><span class="line">            <span class="keyword">return</span> head;</span><br><span class="line">        &#125;</span><br><span class="line">        root.right = insertIntoMaxTree(root.right, val);</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><ul><li><a href="https://leetcode.com/problems/second-minimum-node-in-a-binary-tree/" target="_blank" rel="noopener">Second Minimum Node In a Binary Tree</a><ul><li>需要注意的事，必须将所有的节点都遍历完全才能找到第二小的数字。因为有一个用例将第二小的数值藏在了最下面</li><li>采用DFS或BFS都可以。关键是判断第二小的时候，先要将第一小的数找到，如果之后有数字不是小于<strong>等于</strong>第一小的话，才可以比较是不是第二小。如果只是单纯的小于第一小，会让第二小也成为和第一小一样的数值。</li></ul></li><li>BFS常用结构</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Queue&lt;TreeNode&gt; a = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">a.offer(p);</span><br><span class="line"><span class="keyword">while</span> (!a.isEmpty())&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> sz = a.size(); sz &gt; <span class="number">0</span>; --sz) &#123;</span><br><span class="line">        TreeNode n = a.poll();</span><br><span class="line">        <span class="comment">//do something</span></span><br><span class="line">        a.offer(n.left);</span><br><span class="line">        a.offer(n.right);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 技术总结 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>每周记录📝（190316）</title>
      <link href="/2019/03/16/weeklyReport190316/"/>
      <url>/2019/03/16/weeklyReport190316/</url>
      
        <content type="html"><![CDATA[<p><img src="https://wx1.sinaimg.cn/mw1024/6a49516fly1g14vxty5rbj21400u0e82.jpg" alt="学校的傍晚"></p><p>这一周将毕业设计的开头部分完成了链路打通，具体就是在前端埋点得到的数据能够在kafka中分topic消费。</p><p>其实这之间走了很多弯路，自己反复查资料才发现一个正确的方法。现在才意识到做项目需要一个指导老师的重要性，同样企业需要技术的布道师也是这个道理。</p><p>我的毕设是使用spark streaming进行网站流量的分析。其实对于毕设很尴尬的一点事，没有真实的业务数据，只能自己凭空制造。另外我觉得高校中的毕业设计，真的越来越水，就像是一个大一点的课程设计，自己独立完成的那种。</p><p>这一周我首先想完成通过自己在前端埋点，收集到数据，并能够给后面的业务流程使用。我的前端使用react，埋点的数据收集打算用flume收集。最开始的思路是使用flume的HTTPSource直接收集来自前端POST请求中的数据，可是通过查阅文档发现，无法完成。因为HTTPSource接受的需要是flume的Event对象，前端直接发来的数据不符合要求。所以说前端的任务只要完成原始数据收集的工作就可以了，其他必要的转换由后端完成。</p><p>还有一点就是，经别人提醒，如果说用flume直接收集网络上的数据还有安全的问题（见<a href="https://www.v2ex.com/t/543592#reply4" target="_blank" rel="noopener">V2ex帖子</a>）。所以有后端转发的必要。所以在这里我就有个疑惑，关于HTTPSource的使用场景到底是什么？</p><p>进过反复的尝试，确定了方案是：前端埋点采集到的数据由后端接受，并发送log4j日志给flume，再由flume的interceptor进行过滤（分流），分成不同的topic给kafka的消费者使用，之后就可以给spark streaming使用啦。</p><p>不过现在遗留下的问题就是，前端使用axios出现跨域访问的问题。这个问题下周开始解决。下周要完成的任务就是把前端的框架搭好，开始学习spark streaming深入一点的东西，然后找需求。目前的需求太单薄了，不怎么丰富。</p><p>本周还做了点其他的事，总之效率没有那么高吧。这两天刷LeetCode也刷不起来，不知道为啥。所以这两天休息了一下，没刷。</p><p>感觉自己有的时候总被一些东西打扰，自己的控制力不够。另外看书的速度也挺慢的。看了名人传记，感觉厉害的人为何有那么多精力呢？</p><p>最近看到好玩的图，取名我的毕设，哈哈哈🤣<br><img src="https://wx2.sinaimg.cn/mw1024/6a49516fly1g14w7kwjt8j20j60n4dks.jpg" alt="我的毕设"></p>]]></content>
      
      
      <categories>
          
          <category> 每周记录 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>微信小程序开发🚀</title>
      <link href="/2019/03/15/%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8F%E5%AD%A6%E4%B9%A0%E6%84%8F%E8%A7%81/"/>
      <url>/2019/03/15/%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8F%E5%AD%A6%E4%B9%A0%E6%84%8F%E8%A7%81/</url>
      
        <content type="html"><![CDATA[<h2 id="布局样式📱"><a href="#布局样式📱" class="headerlink" title="布局样式📱"></a>布局样式📱</h2><ul><li><a href="https://www.imooc.com/learn/974" target="_blank" rel="noopener">入门教程视频</a></li><li><a href="http://www.imooc.com/code/49" target="_blank" rel="noopener">基础代码教程</a></li><li>相关实用网站<ul><li><a href="http://www.runoob.com/css/css-tutorial.html" target="_blank" rel="noopener">菜鸟教程</a></li><li><a href="https://developers.weixin.qq.com/miniprogram/dev/quickstart/basic/file.html#wxml-%E6%A8%A1%E6%9D%BF" target="_blank" rel="noopener">WXML与WXSS</a></li><li><a href="https://developers.weixin.qq.com/miniprogram/dev/framework/view/wxss.html" target="_blank" rel="noopener">WXSS主要注意尺寸单位</a></li><li><a href="https://developers.weixin.qq.com/miniprogram/dev/component/" target="_blank" rel="noopener">小程序的基本组件</a></li></ul></li></ul><h2 id="逻辑🗯"><a href="#逻辑🗯" class="headerlink" title="逻辑🗯"></a>逻辑🗯</h2><ul><li><a href="https://developers.weixin.qq.com/community/develop/article/doc/000aa057ca0a88dcd938b4d6656813" target="_blank" rel="noopener">PWA</a>(了解）</li><li><a href="https://www.v2ex.com/t/427255" target="_blank" rel="noopener">关于HTML5/小程序的产生</a>(了解）</li><li><a href="https://developers.weixin.qq.com/miniprogram/dev/quickstart/basic/file.html#js-%E4%BA%A4%E4%BA%92%E9%80%BB%E8%BE%91" target="_blank" rel="noopener">JS逻辑交互</a></li><li>相关实用网站<ul><li><a href="https://developers.weixin.qq.com/miniprogram/dev/quickstart/basic/framework.html#api" target="_blank" rel="noopener">小程序的API</a></li><li><a href="http://www.runoob.com/js/js-tutorial.html" target="_blank" rel="noopener">JavaScript</a></li><li><a href="http://www.runoob.com/json/json-tutorial.html" target="_blank" rel="noopener">JSON教程</a></li></ul></li></ul><h2 id="其他实用网站🕸"><a href="#其他实用网站🕸" class="headerlink" title="其他实用网站🕸"></a>其他实用网站🕸</h2><ul><li><a href="https://developers.weixin.qq.com/" target="_blank" rel="noopener">官方社区</a>:有的坑可能别人已经踩过，可以搜索一下</li><li><a href="https://minapp.com/miniapp/" target="_blank" rel="noopener">知晓程序</a>：可以看看别人产品的想法和思路</li><li><a href="https://tencent.github.io/wepy/" target="_blank" rel="noopener">WePY</a>：开发小程序的一个框架。建议看看就好，还是以原生开发为主。等原生上手后再看看框架。</li><li><a href="https://github.com/Shincey/HFUTSZK" target="_blank" rel="noopener">工大思政课</a>:无网络交互，可以独立开发完成。</li><li><a href="https://github.com/fangmiao97/AISmallTribe-weixinMiniProgram" target="_blank" rel="noopener">AI小部落</a>：js逻辑中有网络交互，可以做参考。</li><li>各种css样式配置web工具<ul><li><a href="https://www.html.cn/tool/css3Preview/Box-Shadow.html" target="_blank" rel="noopener">box、卡片的阴影效果</a></li><li>……</li></ul></li></ul><h2 id="建议🍻"><a href="#建议🍻" class="headerlink" title="建议🍻"></a>建议🍻</h2><ul><li>先学习基础<strong>HTML/CSS/JavaScript</strong>，不用特别抓细节，但是要知晓常见用法</li><li>理清三个方面：<ul><li>如何布局、添加样式</li><li>逻辑层与 ui 层如何交互，或者说如何用代码操控 ui 组件</li><li>如何处理用户的交互动作</li></ul></li><li>先从简单的功能开始开发，如，点击按钮显示图片文本。再逐渐复杂逻辑</li><li>小程序推荐用原生开发，先不要用框架</li><li>看官方文档，也要结合搜索引擎。因为微信的官方文档，有坑</li><li>每天新增一行代码都是进步😃加油！</li><li>逐渐理解<a href="https://developers.weixin.qq.com/miniprogram/dev/framework/app-service/page.html#%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F" target="_blank" rel="noopener">生命周期</a></li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> 开发相关 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
