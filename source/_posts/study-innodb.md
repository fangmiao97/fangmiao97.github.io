---
title: innodb学习笔记
date: 2019/12/28
categories: 
    - 数据库
    - innodb
    - 总结
---
## 索引组织表

在InnoDB存储引擎中，表都是根据主键顺序组织存放的，这种存储方式的表称为索引组织表（index organized table）。在InnoDB存储引擎表中，每张表都有个主键（Primary Key），如果在创建表时没有显式地定义主键，则InnoDB存储引擎会按如下方式选择或创建主键：

* 首先判断表中是否有非空的唯一索引（Unique NOT NULL），如果有，则该列即为主键。

* 如果不符合上述条件，InnoDB存储引擎自动创建一个6字节大小的指针。

## innodb逻辑存储结构 

从InnoDB存储引擎的逻辑存储结构看，所有数据都被逻辑地存放在一个空间中，称之为表空间（tablespace）。表空间又由段（segment）、区（extent）、页（page）组成。页在一些文档中有时也称为块（block），InnoDB存储引擎的逻辑存储结构大致如图4-1所示

![](https://pic.downk.cc/item/5e0860c376085c32893e59c4.jpg)

表空间是由各个段组成的，常见的段有数据段、索引段、回滚段等。

InnoDB存储引擎表是索引组织的（index organized），因此数据即索引，索引即数据。那么数据段即为B+树的叶子节点（图4-1的Leaf nodesegment），索引段即为B+树的非索引节点（图4-1的Non-leaf node segment）

区是由连续页组成的空间，在任何情况下每个区的大小都为1MB。InnoDB存储引擎页的大小为16KB，即一个区中一共有64个连续的页。

InnoDB存储引擎是面向列的（row-oriented），也就说数据是按行进行存放的。

页是InnoDB存储引擎管理数据库的最小磁盘单位。页类型为B-tree Node的页存放的即是表中行的实际数据了。
InnoDB数据页由以下7个部分组成，如图4-6所示。

![](https://pic.downk.cc/item/5e0861a676085c32893e876d.jpg)

需要牢记的是，B+树索引本身并不能找到具体的一条记录，能找到只是该记录所在的页。数据库把页载入到内存，然后通过Page Directory再进行二叉查找。只不过二叉查找的时间复杂度很低，同时在内存中的查找很快，因此通常忽略这部分查找所用的时间。


## 约束

### 数据完整性

关系型数据库系统和文件系统的一个不同点是，关系数据库本身能保证存储数据的完整性，不需要应用程序的控制，而文件系统一般需要在程序端进行控制

数据完整性3种形式：

* 实体完整性

保证表中有一个主键。在InnoDB存储引擎表中，用户可以通过定义PrimaryKey或Unique Key约束来保证实体的完整性。用户还可以通过编写一个触发器来保证数据完整性。

* 域完整性

    保证数据每列的值满足特定的条件。在InnoDB存储引擎表中，域完整性可以通过以下几种途径来保证：
    
    *选择合适的数据类型确保一个数据值满足特定条件。
    
    *外键（Foreign Key）约束。
    
    *编写触发器。
    
    * 还可以考虑用DEFAULT约束作为强制域完整性的一个方面
 
* 参照完整性

保证两张表之间的关系。InnoDB存储引擎支持外键，因此允许用户定义外键以强制参照完整性，也可以通过编写触发器以强制执行。
 
对于InnoDB存储引擎本身而言，提供了以下几种约束：
* Primary Key
* Unique Key
* Foreign Key
* Default 
* NOT NULL

### 创建约束

* create表的时候定义主键等约束

* 通过ALTER TABLE来创建约束

```sql
alter table test add unique key id_num(id_num)
```
### ENUM和SET约束

例如表上有一个性别类型，规定域的范围只能是male或female，在这种情况下用户可以通过ENUM类型来进行约束。

```sql
create table a (id int, sex eum('female', 'male'));
```

### 触发器与约束

触发器的作用是在执行INSERT、DELETE和UPDATE命令之前或之后自动调用SQL命令或存储过程。
最多可以为一个表建立6个触发器，即分别为INSERT、UPDATE、DELETE的BEFORE和AFTER各定义一个。

例如创建对于异常数据插入检测的触发器，当要插入数据库的数据异常时，触发器会将异常信息记录下来，并防止正确的数据被修改。

## 外键约束

外键用来保证参照完整性，两个表之间的约束。学生的班级号必须是班级表里面存在的班级号。

InnoDB存储引擎在外键建立时会自动地对该列加一个索引。

MySQL数据库的外键约束都是即时检查（immediate check）

## 视图

在MySQL数据库中，视图（View）是一个命名的虚表，它由一个SQL查询来定义，可以当做表使用。与持久表（permanent table）不同的是，视图中的数据没有实际的物理存储。
视图是基于基表的一个虚拟表，但是用户可以对某些视图进行更新操作，其本质就是通过视图的定义来更新基本表。

### 物化视图

物化视图的数据存储在非易失的存储设备上。物化视图可以用于预先计算并保存多表的链接（JOIN）或聚集（GROUP BY）等耗时较多的SQL操作结果。

MySQL数据库本身并不支持物化视图，换句话说，MySQL数据库中的视图总是虚拟的。

通过触发器，在MySQL数据库中实现了类似物化视图的功能。

## 分区

分区的过程是将一个表或索引分解为多个更小、更可管理的部分。就访问数据库的应用而言，从逻辑上讲，只有一个表或一个索引，但是在物理上这个表或索引可能由数十个物理分区组成。每个分区都是独立的对象，可以独自处理，也可以作为一个更大对象的一部分进行处理。

MySQL数据库支持的分区类型为水平分（不同行的数据分在不同的区），并不支持垂直分（不同列）。

```sql
create table t1 (
col1 int not null
col2 int not null
col3 int not null
unique key (col1, col2)
)
partition by hash(col1)//分区列必须是unique key的一部分
partitions 4;
```
如果建表时没有指定主键，唯一索引，可以指定任何一个列为分区列。

### 分区类型

* RANGE分区

```sql
create table t1 (
id int 
)engine = innodb
partition by range(id)
partition p0 values less than (10)
partition p1 values less than (20)
```
当插入一个不在分区中定义的值时，MySQL数据库会抛出一个异常。如，我们向表t中插入30这个值.

解决：可以对分区添加一个MAXVALUE值的分区。

分区使用：通过EXPLAIN PARTITION命令我们可以发现，在上述语句中，SQL优化器只需要去搜索p2008这个分区，而不会去搜索所有的分区。在查询语句前加explain partition，同时查询条件要符合要求。

* LIST分区

LIST分区和RANGE分区非常相似，只是分区列的值是离散的，而非连续的。

不同于RANGE分区中定义的VALUES LESS THAN语句，LIST分区使用VALUES IN。因为每个分区的值是离散的，因此只能定义值。

* HASH分区

HASH分区的目的是将数据均匀地分布到预先定义的各个分区中，保证各分区的数据数量大致都是一样的。用户所要做的只是基于将要进行哈希分区的列值指定一个列值或表达式，以及指定被分区的表将要被分割成的分区数量。

```sql
create table t1(
a int,
b date 
)engine = innodb
partition by hash(year(b))
partitions 4;
```

* KEY分区

KEY分区和HASH分区相似，不同之处在于HASH分区使用用户定义的函数进行分区，KEY分区使用MySQL数据库提供的函数进行分区。

* COLUMNS分区

MySQL5.5版本开始支持COLUMNS分区，可视为RANGE分区和LIST分区的一种进化。COLUMNS分区可以直接使用非整型的数据进行分区，分区根据类型直接比较而得，不需要转化为整型。此外，RANGE COLUMNS分区可以对多个列的值进行分区。

### 分区与性能

数据库的应用分为两类：一类是OLTP（在线事务处理），如Blog、电子商务、网络游戏等；另一类是OLAP（在线分析处理），如数据仓库、数据集市。在一个实际的应用环境中，可能既有OLTP的应用，也有OLAP的应用。如网络游戏中，玩家操作的游戏数据库应用就是OLTP的，但是游戏厂商可能需要对游戏产生的日志进行分析，通过分析得到的结果来更好地服务于游戏，预测玩家的行为等，而这却是OLAP的应用

对于OLAP的应用，分区的确是可以很好地提高查询的性能，因为OLAP应用大多数查询需要频繁地扫描一张很大的表。

然而对于OLTP的应用，分区应该非常小心。在这种应用下，通常不可能会获取一张大表中10%的数据，大部分都是通过索引返回几条记录即可。

## innodb索引

InnoDB存储引擎支持以下几种常见的索引：

* B+树索引
* 全文索引
* 哈希索引

InnoDB存储引擎支持的哈希索引是自适应的，InnoDB存储引擎会根据表的使用情况自动为表生成哈希索引，不能人为干预是否在一张表中生成哈希索引。

### 数据结构与算法

* 二分查找

每页Page Directory中的槽是按照主键的顺序存放的，对于某一条具体记录的查询是通过对Page Directory进行二分查找得到的。

* 平衡二叉树

平衡二叉树的定义如下：首先符合二叉查找树的定义，其次必须满足**任何节点**的两个子树的高度最大差为1。

* B+树

平衡查找树+顺序索引（链表）

## B+树索引



